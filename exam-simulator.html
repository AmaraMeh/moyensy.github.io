<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Simulateur d'Examen - Méthodologie de la Présentation</title>
    <meta name="description" content="Simulateur d'examen pour la révision des étudiants en Méthodologie de la Présentation">
    <meta name="author" content="Amara Mehdi">
    <link rel="icon" type="image/png" href="assets/img/icon.png">
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --background: 0 0% 100%;
            --foreground: 222.2 84% 4.9%;
            --card: 0 0% 100%;
            --card-foreground: 222.2 84% 4.9%;
            --primary: 221.2 83.2% 53.3%;
            --primary-foreground: 210 40% 98%;
            --secondary: 210 40% 96.1%;
            --secondary-foreground: 222.2 47.4% 11.2%;
            --muted: 210 40% 96.1%;
            --muted-foreground: 215.4 16.3% 46.9%;
            --accent: 210 40% 96.1%;
            --accent-foreground: 222.2 47.4% 11.2%;
            --border: 214.3 31.8% 91.4%;
            --input: 214.3 31.8% 91.4%;
            --ring: 221.2 83.2% 53.3%;
            --radius: 0.5rem;

            /* Custom colors for correction */
            --correct-color: 120 60% 30%; /* Green */
            --incorrect-color: 0 80% 40%; /* Red */
        }

        .dark {
            --background: 222.2 84% 4.9%;
            --foreground: 210 40% 98%;
            --card: 222.2 84% 4.9%;
            --card-foreground: 210 40% 98%;
            --primary: 217.2 91.2% 59.8%;
            --primary-foreground: 222.2 47.4% 11.2%;
            --secondary: 217.2 32.6% 17.5%;
            --secondary-foreground: 210 40% 98%;
            --muted: 217.2 32.6% 17.5%;
            --muted-foreground: 215 20.2% 65.1%;
            --accent: 217.2 32.6% 17.5%;
            --accent-foreground: 210 40% 98%;
            --border: 217.2 32.6% 17.5%;
            --input: 217.2 32.6% 17.5%;
            --ring: 224.3 76.3% 48%;

             /* Custom colors for correction in dark mode */
            --correct-color: 145 63% 49%; /* Lighter Green */
            --incorrect-color: 350 80% 60%; /* Lighter Red */
        }

        body {
            font-family: 'Poppins', sans-serif;
            background: hsl(var(--background));
            color: hsl(var(--foreground));
            min-height: 100vh;
            -webkit-tap-highlight-color: transparent;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        .exam-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 1rem; /* Adjusted padding for better mobile fit */
        }

        .exam-card {
            background: hsl(var(--card));
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            padding: 1.5rem; /* Adjusted padding */
            margin-bottom: 1.5rem; /* Adjusted margin */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        .timer {
            font-size: 1.25rem; /* Slightly smaller on mobile */
            font-weight: bold;
            color: hsl(var(--primary));
            text-align: center;
            margin: 1rem 0;
        }
         @media (min-width: 640px) { /* Apply larger size on small screens and up */
             .timer {
                 font-size: 1.5rem;
             }
         }


        .question-container {
            margin: 1.5rem 0; /* Adjusted margin */
        }

        .option {
            display: flex;
            align-items: center;
            width: 100%;
            padding: 0.75rem; /* Adjusted padding */
            margin: 0.4rem 0; /* Adjusted margin */
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            background: hsl(var(--card));
            cursor: pointer;
            transition: all 0.3s ease;
            gap: 0.6rem; /* Adjusted gap */
        }

        .option:hover {
            background: hsl(var(--accent));
            border-color: hsl(var(--primary));
        }

        .option input[type="radio"],
        .option input[type="checkbox"] {
            margin-right: 0;
            width: 1.1rem; /* Slightly smaller on mobile */
            height: 1.1rem; /* Slightly smaller on mobile */
            flex-shrink: 0;
        }
         @media (min-width: 640px) {
             .option input[type="radio"],
             .option input[type="checkbox"] {
                  width: 1.2rem;
                  height: 1.2rem;
             }
         }


         /* Style for selected options */
        .option input[type="radio"]:checked + span,
        .option input[type="checkbox"]:checked + span {
             color: hsl(var(--primary-foreground));
        }

        .option input[type="radio"]:checked,
        .option input[type="checkbox"]:checked {
             accent-color: hsl(var(--primary));
        }

         /* Custom class for selected options background */
        .option.selected-option {
            background: hsl(var(--primary));
            color: hsl(var(--primary-foreground));
            border-color: hsl(var(--primary));
        }
        .option.selected-option input[type="radio"],
        .option.selected-option input[type="checkbox"] {
             accent-color: hsl(var(--primary-foreground));
        }


        .theme-toggle, .logout-button {
            position: fixed;
            bottom: 1rem;
            padding: 0.75rem;
            border-radius: 50%;
            background: hsl(var(--primary));
            color: hsl(var(--primary-foreground));
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 50; /* Ensure they are on top */
            border: none; /* Ensure no default button border */
        }
         .theme-toggle {
             right: 1rem;
         }
         .logout-button {
             left: 1rem;
             background: hsl(var(--secondary)); /* Use secondary color for distinction */
             color: hsl(var(--secondary-foreground));
         }
          .logout-button:hover:not(:disabled) {
              background: hsl(var(--secondary-foreground));
              color: hsl(var(--secondary));
          }


        .theme-toggle:hover:not(:disabled), .logout-button:hover:not(:disabled) {
            transform: scale(1.1);
        }
         .theme-toggle:disabled, .logout-button:disabled {
             cursor: not-allowed;
             opacity: 0.8;
         }


        .login-form, .waiting-message {
            max-width: 400px;
            margin: 1.5rem auto; /* Adjusted margin */
            padding: 1.5rem; /* Adjusted padding */
            background: hsl(var(--card));
            border-radius: var(--radius);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            text-align: center;
        }

        .form-input {
            width: 100%;
            padding: 0.75rem;
            margin: 0.5rem 0;
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            background: hsl(var(--input));
            color: hsl(var(--foreground));
        }

        .btn {
            display: inline-block;
            padding: 0.75rem 1.5rem;
            background: hsl(var(--primary));
            color: hsl(var(--primary-foreground));
            border-radius: var(--radius);
            cursor: pointer;
            transition: all 0.3s ease;
            border: none;
            font-weight: 500;
            text-align: center;
            width: auto; /* Default width */
        }
         .btn.w-full { /* Use w-full class explicitly for full width */
             width: 100%;
         }


        .btn:hover:not(:disabled) { /* Apply hover effect only if not disabled */
            opacity: 0.9;
            transform: translateY(-1px);
        }

        .btn:disabled {
            background-color: hsl(var(--muted));
            color: hsl(var(--muted-foreground));
            cursor: not-allowed;
            transform: none;
            opacity: 0.8;
        }


        .leaderboard {
            margin-top: 1.5rem; /* Adjusted margin */
        }

        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem; /* Adjusted padding */
            border-bottom: 1px solid hsl(var(--border));
        }

        .leaderboard-item:last-child {
            border-bottom: none;
        }

        .stats-card {
            background: hsl(var(--card));
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            padding: 1rem;
            margin: 1rem 0;
            text-align: center;
        }

        .stats-number {
            font-size: 1.75rem; /* Slightly smaller */
            font-weight: bold;
            color: hsl(var(--primary));
        }
         @media (min-width: 640px) {
              .stats-number {
                 font-size: 2rem;
              }
         }


        .question-number {
            font-weight: bold;
            color: hsl(var(--primary));
            margin-bottom: 0.5rem;
        }

        .question-text {
            margin-bottom: 0.75rem; /* Adjusted margin */
        }

        .options-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); /* Adjusted min width for mobile */
            gap: 0.75rem; /* Adjusted gap */
            margin: 1rem 0;
        }

        .checkbox-option {
             /* This class was used on the label, now the label *is* the .option */
            display: flex; /* Ensure flexibility */
            align-items: center; /* Vertical alignment */
            gap: 0.5rem; /* Space between checkbox and text */
        }


        .progress-bar {
            width: 100%;
            height: 0.5rem;
            background: hsl(var(--muted));
            border-radius: var(--radius);
            overflow: hidden;
            margin: 1rem 0;
        }

        .progress-fill {
            height: 100%;
            background: hsl(var(--primary));
            transition: width 0.3s ease;
        }

        .countdown-container {
            text-align: center;
            margin: 1.5rem 0; /* Adjusted margin */
        }

        .countdown-title {
            font-size: 1.25rem; /* Adjusted size */
            font-weight: bold;
            margin-bottom: 0.75rem; /* Adjusted margin */
        }
         @media (min-width: 640px) {
             .countdown-title {
                 font-size: 1.5rem;
             }
         }


        .countdown-timer {
            font-size: 2rem; /* Adjusted size */
            font-weight: bold;
            color: hsl(var(--primary));
        }
         @media (min-width: 640px) {
             .countdown-timer {
                 font-size: 2.5rem;
             }
         }


        .rules-container {
            background: hsl(var(--card));
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            padding: 1.5rem; /* Adjusted padding */
            margin: 1.5rem 0; /* Adjusted margin */
        }

        .rules-title {
            font-size: 1.25rem; /* Adjusted size */
            font-weight: bold;
            margin-bottom: 1rem;
            color: hsl(var(--primary));
        }
         @media (min-width: 640px) {
             .rules-title {
                 font-size: 1.5rem;
             }
         }


        .rules-list {
            list-style-type: disc;
            padding-left: 1.25rem; /* Adjusted padding */
            margin: 1rem 0;
            font-size: 0.95rem; /* Slightly smaller text */
        }

        .rules-list li {
            margin: 0.4rem 0; /* Adjusted margin */
        }

        .correction-item {
             border-bottom: 1px solid hsl(var(--border));
             padding: 1rem 0;
        }
         .correction-item:last-child {
             border-bottom: none;
         }
         .correction-item .question-text {
             margin-bottom: 0.5rem;
             font-weight: 500;
         }
         .correction-item .correct-answer {
             color: hsl(var(--correct-color));
             font-weight: bold;
             font-size: 0.9rem;
             margin-top: 0.5rem;
         }
         .correction-item .user-answer {
             color: hsl(var(--incorrect-color));
             font-weight: bold;
             font-size: 0.9rem;
             margin-top: 0.2rem;
         }
         .correction-item .user-answer.correct {
             color: hsl(var(--correct-color));
         }
    </style>
</head>
<body>
    <div class="exam-container">
         <!-- Logout Button (Fixed position) -->
         <button id="logoutBtn" class="logout-button hidden" title="Déconnexion">
            <i class="fas fa-sign-out-alt"></i>
         </button>

        <!-- Login Section -->
        <div id="loginSection" class="login-form">
            <h2 class="text-2xl font-bold mb-4">Simulateur d'Examen</h2>
            <p class="text-lg mb-4">Méthodologie de la Présentation</p>

            <!-- Countdown Section -->
            <div class="countdown-container">
                <div class="countdown-title">Statut de l'examen :</div>
                <div class="countdown-timer" id="countdownTimer">--:--:--</div>
            </div>

            <!-- Rules Section -->
            <div class="rules-container text-left">
                <div class="rules-title">Règlement de l'examen simulé</div>
                <ul class="rules-list">
                    <li>L'examen commence le **19 mai 2025 à 21:00** (Heure d'Algérie - GMT+1)</li>
                    <li>Il se termine le **19 mai 2025 à 22:30** (Heure d'Algérie - GMT+1)</li>
                    <li>Durée totale : **1h30**</li>
                    <li>**30 questions** au total (20 Vrai/Faux et 10 QCM)</li>
                    <li>Barème : **1 point par réponse correcte** (pour les QCM, toutes les bonnes options doivent être cochées et aucune mauvaise)</li>
                    <li>Les résultats et le classement seront affichés à **22:45** (Heure d'Algérie - GMT+1)</li>
                    <li>En cas de problème de connexion, vos réponses seront sauvegardées localement dans votre navigateur.</li>
                    <li>Vous pouvez rejoindre l'examen même après son début, dans la limite du temps disponible.</li>
                </ul>
            </div>

            <div class="stats-card">
                <div class="stats-number" id="registeredCount">0</div>
                <div>Participants enregistrés</div>
            </div>

            <form id="loginForm">
                <input type="text" id="pseudo" class="form-input" placeholder="Pseudo" required>
                <input type="password" id="pin" class="form-input" placeholder="Code PIN (4 chiffres)" pattern="[0-9]{4}" maxlength="4" required>
                <button type="submit" class="btn w-full mt-4">S'enregistrer pour l'examen</button>
            </form>
        </div>

        <!-- Waiting for Exam Section -->
        <div id="waitingSection" class="waiting-message hidden">
            <h2 class="text-2xl font-bold mb-4">Bienvenue <span id="waitingPseudo"></span></h2>
            <div class="countdown-container">
                <div class="countdown-title">Début de l'examen dans :</div>
                <div class="countdown-timer" id="examStartCountdown">--:--:--</div>
            </div>
            <div class="mt-4">
                <p>Veuillez patienter jusqu'à l'heure de début.</p>
                <p>L'examen commencera automatiquement.</p>
            </div>
        </div>

        <!-- Exam Section -->
        <div id="examSection" class="exam-card hidden">
            <div class="flex flex-col sm:flex-row justify-between items-center mb-4">
                <div class="timer mb-4 sm:mb-0" id="timer">01:30:00</div>
                <div class="stats-card w-full sm:w-auto">
                    <div class="stats-number" id="questionProgress">0/30</div>
                    <div>Questions répondues</div>
                </div>
            </div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill" style="width: 0%"></div>
            </div>
            <form id="examForm">
                 <div id="questionsContainer" class="question-container">
                     <!-- Questions will be dynamically added here -->
                 </div>
                <button type="submit" id="submitExam" class="btn w-full mt-4">Soumettre l'examen</button>
            </form>
        </div>

        <!-- Waiting for Results Section -->
        <div id="waitingResultsSection" class="waiting-message hidden">
             <h2 class="text-2xl font-bold mb-4">Examen soumis !</h2>
             <p class="mb-4">Merci d'avoir participé.</p>
             <div class="countdown-container">
                 <div class="countdown-title">Les résultats seront disponibles dans :</div>
                 <div class="countdown-timer" id="resultsCountdown">--:--:--</div>
             </div>
             <div class="mt-4">
                 <p>Revenez après 22:45 (Heure d'Algérie) pour consulter les résultats et le classement.</p>
             </div>
        </div>


        <!-- Results Section -->
        <div id="resultsSection" class="exam-card hidden">
            <h2 class="text-2xl font-bold mb-4">Résultats et Classement</h2>

             <div id="userResultSummary" class="mb-6 hidden">
                 <div class="stats-card">
                     <div class="stats-number" id="userScore">--/30</div>
                     <div>Votre score</div>
                 </div>
                 <button id="showCorrectionBtn" class="btn mt-4">Voir la correction</button>
             </div>

            <div class="stats-card">
                <div class="stats-number" id="submittedCount">0</div>
                <div>Participants ayant soumis</div>
            </div>

            <div class="leaderboard">
                <h3 class="text-xl font-bold mb-2">Classement</h3>
                <div id="leaderboardList">
                    <!-- Leaderboard will be dynamically added here -->
                     <div class="text-center p-4 text-muted-foreground">Chargement du classement...</div>
                </div>
            </div>

             <div id="correctionSection" class="correction-section mt-8 hidden">
                 <h3 class="text-xl font-bold mb-4">Votre Correction</h3>
                 <div id="correctionList">
                     <!-- Correction will be dynamically added here -->
                 </div>
             </div>
        </div>
    </div>

    <button id="themeToggle" class="theme-toggle" title="Changer de thème">
        <i class="fas fa-moon"></i>
    </button>


    <!-- Firebase SDK (Modular style using gstatic URLs) -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js";
        import { getFirestore, doc, getDoc, setDoc, collection, addDoc, getDocs, query, orderBy, limit, serverTimestamp, onSnapshot, where, increment } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js";
        // getAnalytics was requested but isn't used in this specific logic
        // import { getAnalytics } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-analytics.js";


        // Your web app's Firebase configuration (UPDATED)
        const firebaseConfig = {
            apiKey: "AIzaSyB5XYqWKhHdiVDXJx4iOwtpxD8eUCPRfKU",
            authDomain: "universite-de-bejaia-547fc.firebaseapp.com",
            databaseURL: "https://universite-de-bejaia-547fc-default-rtdb.europe-west1.firebasedatabase.app", // Note: Realtime Database URL, but we are using Firestore
            projectId: "universite-de-bejaia-547fc",
            storageBucket: "universite-de-bejaia-547fc.firebasestorage.app",
            messagingSenderId: "517622731583",
            appId: "1:517622731583:web:25453d5e01226585bf798a",
            measurementId: "G-SQ0WWSCS7B" // Analytics ID
        };


        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        // const analytics = getAnalytics(app); // Analytics initialized but not used in exam logic

        // Helper function to get current time in Algeria (GMT+1) - MOVED HERE
        function getAlgeriaTime() {
            const now = new Date();
            // Corrected typo: getTimezoneOffset
            const utc = now.getTime() + (now.getTimezoneOffset() * 60000); // Convert to UTC
            return new Date(utc + (1 * 60 * 60 * 1000)); // Add GMT+1 offset
        }


        // Exam Timings (Algeria Time GMT+1) - Using 2025 dates as requested
        const EXAM_START_TIME = new Date('2025-05-19T21:00:00+01:00');
        const EXAM_END_TIME = new Date('2025-05-19T22:30:00+01:00'); // 1h30 duration
        const RESULTS_TIME = new Date('2025-05-19T22:45:00+01:00');

        // UI Elements
        const loginSection = document.getElementById('loginSection');
        const waitingSection = document.getElementById('waitingSection');
        const examSection = document.getElementById('examSection');
        const waitingResultsSection = document.getElementById('waitingResultsSection');
        const resultsSection = document.getElementById('resultsSection');

        const countdownTimerElement = document.getElementById('countdownTimer');
        const examStartCountdownElement = document.getElementById('examStartCountdown');
        const examTimerElement = document.getElementById('timer');
        const resultsCountdownElement = document.getElementById('resultsCountdown');

        const loginForm = document.getElementById('loginForm');
        const pseudoInput = document.getElementById('pseudo');
        const pinInput = document.getElementById('pin');
        const registeredCountElement = document.getElementById('registeredCount');
        const submittedCountElement = document.getElementById('submittedCount');

        const questionsContainer = document.getElementById('questionsContainer');
        const questionProgressElement = document.getElementById('questionProgress');
        const progressFillElement = document.getElementById('progressFill');
        const submitExamButton = document.getElementById('submitExam');

        const userResultSummaryElement = document.getElementById('userResultSummary');
        const userScoreElement = document.getElementById('userScore');
        const leaderboardListElement = document.getElementById('leaderboardList');
        const correctionSectionElement = document.getElementById('correctionSection');
        const correctionListElement = document.getElementById('correctionList');
        const showCorrectionBtn = document.getElementById('showCorrectionBtn');
         const logoutBtn = document.getElementById('logoutBtn');


        // Questions data (Integrated from your list)
        const questions = [
            // Question 1: Vrai ou Faux (20 questions)
            { type: 'trueFalse', text: 'Faire un exposé oral implique de présenter les résultats d\'un travail de recherche devant un auditoire.', answer: true },
            { type: 'trueFalse', text: 'L\'un des buts de l\'exposé oral est de convaincre l\'auditoire.', answer: true },
            { type: 'trueFalse', text: 'Un exposé oral efficace ne nécessite pas d\'être visuel ou expressif.', answer: false },
            { type: 'trueFalse', text: 'Pour préparer un exposé oral, il est nécessaire de trouver une problématique et d\'y répondre de façon argumentée.', answer: true },
            { type: 'trueFalse', text: 'Lorsque l\'on utilise Internet pour un exposé, il est important de trier les sources et d\'analyser les documents pertinents.', answer: true },
            { type: 'trueFalse', text: 'Pour une présentation orale, le plan structuré doit idéalement comporter cinq parties ou plus.', answer: false },
            { type: 'trueFalse', text: 'Lors d\'une présentation orale, il est préférable d\'écrire l\'intégralité de son texte sur les supports (comme des notes) pour éviter d\'oublier des points.', answer: false },
            { type: 'trueFalse', text: 'L\'échelle de déformation du message décrit une perte progressive du message entre l\'émetteur et le récepteur.', answer: true },
            { type: 'trueFalse', text: 'Le "Code" dans le schéma de communication est la personne qui est à l\'origine du message.', answer: false },
            { type: 'trueFalse', text: 'Le corps et la voix sont des instruments de l\'expression orale.', answer: true },
            { type: 'trueFalse', text: 'La façon de s\'exprimer oralement ne change pas en fonction de l\'interlocuteur (ami, collègue, supérieur).', answer: false },
            { type: 'trueFalse', text: 'La respiration est importante car elle conditionne la bonne émission du son et favorise la détente.', answer: true },
            { type: 'trueFalse', text: 'L\'Intonation est le mouvement mélodique de la voix.', answer: true },
            { type: 'trueFalse', text: 'Un débit de parole uniforme est conseillé pour éviter de perturber l\'auditoire.', answer: false },
            { type: 'trueFalse', text: 'L\'Articulation est le fait de varier le ton de la voix.', answer: false },
            { type: 'trueFalse', text: 'Le trac est la peur ressentie avant d\'affronter un public.', answer: true },
            { type: 'trueFalse', text: 'Le trac ne se dissipe pas dans l\'action, il ne fait qu\'empirer.', answer: false },
            { type: 'trueFalse', text: 'La répétition d\'un mot ou d\'une expression est une technique inutile en expression orale.', answer: false },
            { type: 'trueFalse', text: 'Le silence pendant un exposé permet notamment de reprendre son souffle et de regarder l\'auditoire.', answer: true },
            { type: 'trueFalse', text: 'Le regard de l\'orateur peut transmettre des sentiments ou des volontés.', answer: true },
            // Question 2: QCM (10 questions)
            { type: 'multiple', text: 'Selon le cours, quels sont les principaux facteurs du schéma de communication ?', options: ['Le Rythme', 'Le Récepteur', 'Le Support Visuel', 'Le Canal', 'Le Message'], answer: [1, 3, 4] }, // Indices des bonnes réponses
            { type: 'multiple', text: 'Parmi les éléments suivants, lesquels font partie des techniques d\'expression orale liées à la voix, telles que décrites dans le cours ?', options: ['Les Gestes', 'Le Débit', 'La Posture', 'La Modulation', 'L\'Articulation'], answer: [1, 3, 4] },
            { type: 'multiple', text: 'Le trac peut entraîner les manifestations physiques suivantes :', options: ['Jambes molles', 'Sentiment d\'oppression', 'Langue desséchée', 'Grande confiance en soi', 'Crampes'], answer: [0, 1, 2, 4] },
            { type: 'multiple', text: 'Selon le cours, la gestion du trac peut être améliorée par :', options: ['Une préparation insuffisante pour stimuler l\'adrénaline', 'La relaxation physique et mentale', 'Un entraînement régulier', 'L\'amélioration de la respiration', 'La consommation de boissons énergisantes'], answer: [1, 2, 3] },
            { type: 'multiple', text: 'Quelle(s) distance(s) de communication interpersonnelle est/sont décrite(s) dans le cours ?', options: ['La zone Intime', 'La zone Professionnelle', 'La zone Sociale', 'La zone Personnelle', 'La zone Publique'], answer: [0, 2, 3, 4] },
            { type: 'multiple', text: 'Selon le Chapitre 2, la réussite d\'une présentation orale dépend de :', options: ['La qualité de l\'oralité', 'La complexité des graphiques utilisés', 'La rigueur du support visuel', 'La pertinence du contenu'], answer: [0, 2, 3] },
            { type: 'multiple', text: 'Quelle est la structure temporelle recommandée pour les différentes parties d\'une présentation orale ?', options: ['L\'introduction représente 10% du temps.', 'Le corps représente la majeure partie du temps.', 'La conclusion doit être aussi longue que l\'introduction.', 'Le corps représente 80% du temps.'], answer: [0, 1, 3] },
            { type: 'multiple', text: 'Lors de la conception des diapositives, que recommande le cours concernant la typographie ?', options: ['Utiliser uniquement des polices fantaisie pour capter l\'attention.', 'Préférer des polices comme ARIAL ou UNIVERS.', 'La taille minimale des caractères doit être de 18 points.', 'La taille idéale des caractères est entre 26 et 28 points.'], answer: [1, 2, 3] },
            { type: 'multiple', text: 'Concernant le graphisme des diapositives, quels conseils sont donnés ?', options: ['Utiliser un fond différent pour chaque diapositive.', 'Préférer un fond uni et identique pour toutes les diapositives.', 'Utiliser des couleurs agressives comme le rouge vif pour les titres.', 'Éviter le souligné en écriture électronique.'], answer: [1, 3] },
            { type: 'multiple', text: 'Que faut-il éviter lors de la création du support visuel selon le cours ?', options: ['Les fautes d\'orthographe.', 'L\'écriture en majuscules.', 'L\'abus d\'animations complexes.', 'De mettre des mots-clés sur les diapositives.'], answer: [0, 1, 2] }
        ];


        // --- Firebase Counters for Registered Participants ---
        // Using 'methodologie_presentation_registered' as the counter key for this specific exam
        const registeredCounterRef = doc(db, 'counters', 'methodologie_presentation_registered');

        // Initialize counter if it doesn't exist
        const initializeRegisteredCounter = async () => {
            try {
                const counterDoc = await getDoc(registeredCounterRef);
                if (!counterDoc.exists()) {
                    await setDoc(registeredCounterRef, { count: 0 });
                }
            } catch (error) {
                console.error("Error initializing registered counter:", error);
                // Log error, but don't block the app
            }
        };

        // Listen for real-time updates to the registered counter
        let unsubscribeRegisteredCounter = null; // Keep track of listener
        const startRegisteredCounterListener = () => {
             if (!unsubscribeRegisteredCounter) { // Only start if not already listening
                unsubscribeRegisteredCounter = onSnapshot(registeredCounterRef, (doc) => {
                    if (doc.exists()) {
                        registeredCountElement.textContent = doc.data().count;
                    } else {
                         registeredCountElement.textContent = 'N/A'; // Should ideally not happen if initialized
                    }
                }, (error) => {
                     console.error("Error listening to registered counter:", error);
                     registeredCountElement.textContent = 'Erreur';
                });
             }
        };
        const stopRegisteredCounterListener = () => {
             if (unsubscribeRegisteredCounter) {
                 unsubscribeRegisteredCounter();
                 unsubscribeRegisteredCounter = null;
             }
        };


        // --- Firebase Exam Results ---
        const examResultsCollection = collection(db, 'examResults_methodologie'); // Using a specific collection for this exam


        // --- Countdown & Timer Logic ---
        let examTimerInterval = null;
        let globalCountdownInterval = null;
        let resultsCountdownInterval = null;

        function formatTime(ms) {
            if (ms < 0) ms = 0;
            const totalSeconds = Math.floor(ms / 1000);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        function updateGlobalCountdown() {
            const now = getAlgeriaTime();

            // If after results time
            if (now >= RESULTS_TIME) {
                clearAllIntervals(); // Clear all timers/countdowns
                countdownTimerElement.textContent = "Résultats disponibles";
                showResults();
                return;
            }

            // If during exam
            if (now >= EXAM_START_TIME && now < EXAM_END_TIME) {
                 // Note: The logic to transition to exam state for logged-in users
                 // happens primarily on login submit or window load check.
                 // This global countdown just updates the text on the login screen.
                 countdownTimerElement.textContent = "Examen en cours";

                  // If currently showing waitingForResults (edge case when results time passes)
                  if (waitingResultsSection.classList.contains('hidden') === false && now < RESULTS_TIME) {
                      showWaitingForResults(); // Re-assert waiting state if needed
                  } else if (loginSection.classList.contains('hidden') && examSection.classList.contains('hidden') && waitingSection.classList.contains('hidden') && resultsSection.classList.contains('hidden')) {
                      // If no section is currently visible (e.g., after manual time change or refresh)
                       const savedUser = localStorage.getItem('examUser');
                       if (savedUser) {
                           startExam(JSON.parse(savedUser)); // Go to exam if logged in
                       } else {
                           showLogin(); // Go to login if not logged in
                       }
                  }


                 return; // Continue global countdown loop if not yet at results time
            }

            // If after exam but before results
            if (now >= EXAM_END_TIME && now < RESULTS_TIME) {
                 const timeToResults = RESULTS_TIME - now;
                 countdownTimerElement.textContent = `Résultats dans ${formatTime(timeToResults)}`;

                 // Transition to waiting for results screen if not already there
                 if (waitingResultsSection.classList.contains('hidden')) {
                     showWaitingForResults(); // This starts the results countdown
                 }
                 return; // Continue global countdown loop
            }

            // If before exam
            if (now < EXAM_START_TIME) {
                const timeToStart = EXAM_START_TIME - now;
                countdownTimerElement.textContent = `Début dans ${formatTime(timeToStart)}`;

                 // If currently showing exam or waiting results (edge case)
                 if (examSection.classList.contains('hidden') === false || waitingResultsSection.classList.contains('hidden') === false) {
                      // If somehow on exam or waiting results screen before exam start,
                      // redirect based on login state
                       const savedUser = localStorage.getItem('examUser');
                       if (savedUser) {
                            showWaitingForExam(JSON.parse(savedUser).pseudo);
                            startExamStartCountdown();
                       } else {
                           showLogin();
                       }
                 }

                 return; // Continue global countdown loop
            }

             // Fallback, should not be reached if logic is correct
            countdownTimerElement.textContent = "Statut inconnu";
        }

        function startExamStartCountdown() {
             // Clear any existing start countdown to prevent multiple intervals
             if (waitingSection.dataset.intervalId) {
                 clearInterval(parseInt(waitingSection.dataset.intervalId));
             }

             const interval = setInterval(() => {
                 const now = getAlgeriaTime();
                 const timeToStart = EXAM_START_TIME - now;

                 if (timeToStart <= 0) {
                     clearInterval(interval);
                     delete waitingSection.dataset.intervalId; // Clear interval ID from dataset
                     // Transition to exam
                     const savedUser = localStorage.getItem('examUser');
                     if(savedUser) {
                          const userData = JSON.parse(savedUser);
                          startExam(userData); // Start the exam UI
                          // Stop the global countdown interval on login page if it's still running
                          if(globalCountdownInterval) {
                             clearInterval(globalCountdownInterval);
                             globalCountdownInterval = null;
                          }
                     } else {
                          // Should not happen if flow is correct, but as fallback
                          showLogin();
                     }
                     return;
                 }

                 examStartCountdownElement.textContent = formatTime(timeToStart);
             }, 1000);

             waitingSection.dataset.intervalId = interval.toString(); // Store interval ID as string
        }

        function startExamTimer() {
            // Clear any existing exam timer
            if (examTimerInterval) {
                 clearInterval(examTimerInterval);
            }

            const now = getAlgeriaTime();
            let durationMs = EXAM_END_TIME - now; // Time left until the end of the exam in milliseconds

            if (durationMs <= 0) {
                 // Exam already ended or will end immediately
                 examTimerElement.textContent = "00:00:00";
                 // Use a small timeout to ensure the UI updates before submitting
                 setTimeout(submitExam, 50); // Submit immediately
                 return;
            }

            examTimerElement.textContent = formatTime(durationMs);

            examTimerInterval = setInterval(() => {
                durationMs -= 1000; // Decrease by 1 second

                if (durationMs <= 0) {
                    clearInterval(examTimerInterval);
                    examTimerInterval = null; // Clear interval ID
                    examTimerElement.textContent = "00:00:00";
                    submitExam(); // Time's up, submit
                    return;
                }

                examTimerElement.textContent = formatTime(durationMs);
            }, 1000);
        }

         function updateResultsCountdown() {
             const now = getAlgeriaTime();
             const timeToResults = RESULTS_TIME - now;

             if (timeToResults <= 0) {
                 clearAllIntervals(); // Clear all timers/countdowns
                 showResults(); // Time to show results
                 return;
             }

             resultsCountdownElement.textContent = formatTime(timeToResults);
         }

         function clearAllIntervals() {
             if (examTimerInterval) clearInterval(examTimerInterval);
             if (globalCountdownInterval) clearInterval(globalCountdownInterval);
             if (resultsCountdownInterval) clearInterval(resultsCountdownInterval);
             if (waitingSection.dataset.intervalId) clearInterval(parseInt(waitingSection.dataset.intervalId));

             examTimerInterval = null;
             globalCountdownInterval = null;
             resultsCountdownInterval = null;
             delete waitingSection.dataset.intervalId;
         }

        // --- UI State Management ---
        function hideAllSections() {
            loginSection.classList.add('hidden');
            waitingSection.classList.add('hidden');
            examSection.classList.add('hidden');
            waitingResultsSection.classList.add('hidden');
            resultsSection.classList.add('hidden');
            logoutBtn.classList.add('hidden'); // Hide logout by default
        }

        function showLogin() {
             hideAllSections();
             loginSection.classList.remove('hidden');
             // Ensure global countdown is running for login screen status
             if(!globalCountdownInterval) {
                 globalCountdownInterval = setInterval(updateGlobalCountdown, 1000);
             }
             updateGlobalCountdown(); // Initial call to set status text
             // Hide logout button on login page
             logoutBtn.classList.add('hidden');
             stopRegisteredCounterListener(); // Stop listener when not on login/results
        }

        function showWaitingForExam(pseudo) {
            hideAllSections();
            waitingSection.classList.remove('hidden');
            document.getElementById('waitingPseudo').textContent = pseudo;
             // Show logout button when logged in and waiting
             logoutBtn.classList.remove('hidden');
             stopRegisteredCounterListener(); // Stop listener when waiting for exam
        }

        function startExam(userData) {
            hideAllSections();
            examSection.classList.remove('hidden');
            displayQuestions(); // Render questions
            loadSavedAnswers(); // Load answers from local storage
            updateProgress(); // Update progress based on loaded answers
            startExamTimer(); // Start the countdown timer
             // Show logout button during exam
             logoutBtn.classList.remove('hidden');
             stopRegisteredCounterListener(); // Stop listener during exam
             // Ensure global countdown stops if it was running on the login page
             if(globalCountdownInterval) {
                 clearInterval(globalCountdownInterval);
                 globalCountdownInterval = null;
             }
        }

        function showWaitingForResults() {
             hideAllSections();
             waitingResultsSection.classList.remove('hidden');
              // Start results countdown if not already running
             if(!resultsCountdownInterval) {
                 resultsCountdownInterval = setInterval(updateResultsCountdown, 1000);
                 updateResultsCountdown(); // Call immediately
             }
              // Show logout button if user was logged in when exam ended/submitted
             const savedUser = localStorage.getItem('examUser');
             if(savedUser) {
                 logoutBtn.classList.remove('hidden');
             } else {
                  logoutBtn.classList.add('hidden'); // Should be hidden if not logged in
             }
             stopRegisteredCounterListener(); // Stop listener when waiting for results
        }

        async function showResults() {
            hideAllSections();
            resultsSection.classList.remove('hidden');
            startRegisteredCounterListener();

            // Clear previous user-specific content first
            userResultSummaryElement.innerHTML = '';
            userResultSummaryElement.classList.add('hidden');
            correctionListElement.innerHTML = '';
            correctionSectionElement.classList.add('hidden');

            const savedUser = localStorage.getItem('examUser');
            if (savedUser) {
                const userData = JSON.parse(savedUser);
                try {
                    const userResultQuery = query(examResultsCollection, where('pseudo', '==', userData.pseudo), limit(1));
                    const userResultSnapshot = await getDocs(userResultQuery);

                    if (!userResultSnapshot.empty) {
                        const userResult = userResultSnapshot.docs[0].data();
                        userResultSummaryElement.innerHTML = `
                            <div class="stats-card">
                                <div class="stats-number">${userResult.score}/${questions.length}</div>
                                <div>Votre score</div>
                            </div>
                        `;
                        userResultSummaryElement.classList.remove('hidden');
                        displayCorrection(userResult.userAnswers, false); // Personalized correction
                    } else {
                        userResultSummaryElement.innerHTML = `<div class="stats-card"><p>Aucun résultat trouvé pour ${userData.pseudo}. Vous n'avez peut-être pas soumis l'examen.</p></div>`;
                        userResultSummaryElement.classList.remove('hidden');
                        displayCorrection(null, true); // Generic correction
                    }
                } catch (error) {
                    console.error("Error fetching user result:", error);
                    userResultSummaryElement.innerHTML = `<div class="stats-card"><p>Erreur lors du chargement de vos résultats.</p></div>`;
                    userResultSummaryElement.classList.remove('hidden');
                    displayCorrection(null, true); // Generic correction on error
                }
                logoutBtn.classList.remove('hidden');
            } else {
                // Not logged in
                userResultSummaryElement.classList.add('hidden'); // Ensure score section is hidden
                displayCorrection(null, true); // Show generic correction
                logoutBtn.classList.add('hidden');
            }

            // Update general stats (submitted count) and leaderboard for everyone
            await updateSubmittedCount();
            await updateLeaderboard();
        }

        // --- Login Functionality ---
        loginForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const now = getAlgeriaTime();

            // Check time bounds before proceeding
             if (now < EXAM_START_TIME) {
                alert(`L'examen n'a pas encore commencé. Il débutera le ${EXAM_START_TIME.toLocaleString('fr-FR', {dateStyle: 'short', timeStyle: 'short'})} (Heure d'Algérie).`);
                return;
             }
            if (now >= EXAM_END_TIME && now < RESULTS_TIME) {
                alert("L'examen est terminé. Les résultats seront disponibles à 22:45 (heure d'Algérie).");
                showWaitingForResults(); // Redirect to waiting for results
                return;
            }
             if (now >= RESULTS_TIME) {
                alert("Les résultats sont disponibles.");
                showResults(); // Redirect to results
                return;
            }


            const pseudo = pseudoInput.value.trim();
            const pin = pinInput.value; // PIN validation is pattern/maxlength on input

            if (!pseudo) {
                 alert("Veuillez entrer un Pseudo.");
                 return;
            }
             // Basic PIN format check
             if (!/^[0-9]{4}$/.test(pin)) {
                 alert("Le Code PIN doit être composé de 4 chiffres.");
                 return;
             }

            // Check if pseudo already has a *submitted* result to prevent duplicates
            try {
                const existingResultQuery = query(examResultsCollection, where('pseudo', '==', pseudo));
                const existingResultSnapshot = await getDocs(existingResultQuery);
                 if (!existingResultSnapshot.empty) {
                      // Check if there's a PIN match for existing user (if PIN was saved)
                      // Currently, PIN isn't strongly used for verification on return login.
                      // We'll block if a result exists with this pseudo.
                     alert(`Un résultat existe déjà pour le pseudo "${pseudo}". Vous ne pouvez soumettre l'examen qu'une seule fois.`);
                     return; // Prevent multiple submissions from same pseudo
                 }
            } catch (error) {
                 console.error("Error checking for existing result:", error);
                 // Allow proceeding if Firebase check fails? Or block? Let's block for safety.
                 alert("Une erreur est survenue lors de la vérification de votre pseudo. Veuillez vérifier votre connexion ou réessayer.");
                 return;
            }

            // Store user data locally upon successful pseudo/pin validation and check
            const userData = { pseudo, pin };
            localStorage.setItem('examUser', JSON.stringify(userData));

            // Increment participant counter
             try {
                await setDoc(registeredCounterRef, { count: increment(1) }, { merge: true });
             } catch (error) {
                 console.error("Error incrementing registered counter:", error);
                 // Log error, but don't prevent user from taking the exam
             }

            // Determine next state based on time (during exam)
             startExam(userData); // User logged in during the exam window, go to exam
             // Note: The "before exam" case is handled by the time checks at the start of this listener
             // and the initial load logic which directs to the waiting screen.

        });

         // --- Logout Functionality ---
         logoutBtn.addEventListener('click', handleLogout);

         function handleLogout() {
             // Check if currently in exam state
             const inExam = !examSection.classList.contains('hidden');

             if (inExam) {
                 if (!confirm("Vous êtes en train de passer l'examen. Si vous vous déconnectez, votre progression locale sera perdue et votre examen ne sera pas soumis. Voulez-vous continuer la déconnexion ?")) {
                     return; // User cancelled logout
                 }
                 // If user confirms during exam, attempt to save answers before logging out
                 saveAnswers(); // Save current state locally just in case
             } else {
                  // If not in exam, just ask for confirmation
                 if (!confirm("Voulez-vous vraiment vous déconnecter ?")) {
                     return; // User cancelled logout
                 }
             }

             localStorage.removeItem('examUser');
             localStorage.removeItem('examAnswers'); // Also clear saved answers on logout
             clearAllIntervals(); // Stop all timers/intervals
             showLogin(); // Go back to the login screen
             alert("Vous avez été déconnecté.");
         }


        // --- Exam Logic ---
        function displayQuestions() {
            questionsContainer.innerHTML = ''; // Clear existing questions
            questions.forEach((question, index) => {
                const questionElement = document.createElement('div');
                questionElement.className = 'mb-8';
                questionElement.setAttribute('data-question-index', index); // Add index attribute for easier lookup

                questionElement.innerHTML = `
                    <div class="question-number">Question ${index + 1}</div>
                    <div class="question-text">${question.text}</div>
                    ${question.type === 'trueFalse' ? `
                        <div class="options-grid">
                            <label class="option" data-q="${index}" data-value="true">
                                <input type="radio" name="q${index}" value="true" required>
                                <span>Vrai</span>
                            </label>
                            <label class="option" data-q="${index}" data-value="false">
                                <input type="radio" name="q${index}" value="false" required>
                                <span>Faux</span>
                            </label>
                        </div>
                    ` : `
                        <div class="options-grid">
                            ${question.options.map((option, optIndex) => `
                                <label class="option checkbox-option" data-q="${index}" data-value="${optIndex}">
                                    <input type="checkbox" name="q${index}" value="${optIndex}">
                                    <span>${option}</span>
                                </label>
                            `).join('')}
                        </div>
                    `}
                `;
                questionsContainer.appendChild(questionElement);
            });

             // Add event listener for answer selection to save and update progress
            questionsContainer.addEventListener('change', handleAnswerChange);

             // Add visual feedback for selected options (re-delegate the click/change logic)
             // The change listener handles both the data saving and the class update now.
        }

        function handleAnswerChange(e) {
            const input = e.target;
            if (input.matches('input[type="radio"], input[type="checkbox"]')) {
                 saveAnswers(); // Save all answers on any change
                 updateProgress(); // Update progress bar
                 updateOptionClasses(); // Update visual selected class
            }
        }

         function updateOptionClasses() {
             // Loop through all questions displayed
             questionsContainer.querySelectorAll('.mb-8').forEach(questionElement => {
                 const qIndex = questionElement.getAttribute('data-question-index');
                 const options = questionElement.querySelectorAll('.option');
                 options.forEach(label => {
                     const input = label.querySelector('input');
                     if (input && input.checked) {
                         label.classList.add('selected-option');
                     } else {
                         label.classList.remove('selected-option');
                     }
                 });
             });
         }


        function saveAnswers() {
            const answers = {};
            questionsContainer.querySelectorAll('.mb-8').forEach(questionElement => {
                 const index = parseInt(questionElement.getAttribute('data-question-index'));
                 const selectedInputs = questionElement.querySelectorAll(`input[name="q${index}"]:checked`);

                if (selectedInputs.length > 0) {
                    if (questions[index].type === 'trueFalse') {
                         // For radio, only one is checked
                        answers[index] = selectedInputs[0].value === 'true';
                    } else { // multiple choice
                         // For checkbox, collect all checked values
                        answers[index] = Array.from(selectedInputs).map(input => parseInt(input.value));
                    }
                 }
                 // If selectedInputs.length is 0, the key is simply not added to the answers object, meaning unanswered
            });
            localStorage.setItem('examAnswers', JSON.stringify(answers));
        }

        function loadSavedAnswers() {
            const savedAnswers = localStorage.getItem('examAnswers');
            if (savedAnswers) {
                try {
                    const answers = JSON.parse(savedAnswers);
                    questionsContainer.querySelectorAll('.mb-8').forEach(questionElement => {
                        const qIndex = parseInt(questionElement.getAttribute('data-question-index'));
                        const userAnswer = answers[qIndex]; // Can be undefined if not saved

                        if (userAnswer !== undefined) { // Only try to load if there's a saved answer for this question
                            if (questions[qIndex].type === 'trueFalse') {
                                 // Check if the user answer (boolean) matches the value string ('true' or 'false')
                                const input = questionElement.querySelector(`input[name="q${qIndex}"][value="${userAnswer}"]`);
                                if (input) {
                                    input.checked = true;
                                }
                            } else { // multiple choice
                                if (Array.isArray(userAnswer)) {
                                    userAnswer.forEach(optIndex => {
                                        const input = questionElement.querySelector(`input[name="q${qIndex}"][value="${optIndex}"][type="checkbox"]`);
                                        if (input) {
                                            input.checked = true;
                                        }
                                    });
                                }
                            }
                        }
                    });
                     updateOptionClasses(); // Apply selected style after loading
                } catch (e) {
                    console.error("Failed to load saved answers from localStorage:", e);
                    localStorage.removeItem('examAnswers'); // Clear potentially corrupted data
                    alert("Erreur: Impossible de charger vos réponses sauvegardées localement.");
                }
            }
        }


        function updateProgress() {
            let answeredCount = 0;
             // Count questions that have *any* option checked
             questionsContainer.querySelectorAll('.mb-8').forEach(questionElement => {
                 const selectedInputs = questionElement.querySelectorAll('input:checked');
                 if (selectedInputs.length > 0) {
                     answeredCount++;
                 }
             });

            questionProgressElement.textContent = `${answeredCount}/${questions.length}`;
            progressFillElement.style.width = `${(answeredCount / questions.length) * 100}%`;
        }


        function calculateScore(userAnswersObject) {
            let score = 0;
            questions.forEach((question, index) => {
                // Get user answer from the object passed to the function
                const userAnswer = userAnswersObject ? userAnswersObject[index] : undefined;

                if (userAnswer === undefined) {
                    // Question was not answered, score is 0 for this question
                    return; // Continue to next question
                }

                if (question.type === 'trueFalse') {
                    // Check if user answer matches correct answer (1 point for correct TF)
                    if (userAnswer === question.answer) {
                        score++;
                    }
                } else { // multiple choice
                    // Check if the array of selected indices exactly matches the array of correct indices (1 point for perfectly answered MCQ)
                    const correctAnswers = question.answer.slice().sort(); // Get a copy and sort
                    const submittedAnswers = Array.isArray(userAnswer) ? userAnswer.slice().sort() : []; // Get a copy and sort submitted answers

                     if (submittedAnswers.length === correctAnswers.length &&
                         submittedAnswers.every((val, i) => val === correctAnswers[i])) {
                        score++;
                    }
                }
            });
            return score;
        }

        // Submit Exam
        document.getElementById('examForm').addEventListener('submit', async (e) => {
             e.preventDefault(); // Prevent default form submission
             await submitExam(); // Call the async submit function
        });


        async function submitExam() {
            const now = getAlgeriaTime();

            // Check if exam time has already passed
             if (now >= EXAM_END_TIME) {
                 alert("L'heure limite de l'examen est dépassée. Votre examen ne peut pas être soumis.");
                 // Transition to the next state (waiting for results or results)
                 if (now < RESULTS_TIME) {
                     showWaitingForResults();
                 } else {
                     showResults();
                 }
                 return; // Stop submission
             }

             // Disable submit button immediately to prevent double clicks
             submitExamButton.disabled = true;
             submitExamButton.textContent = 'Soumission en cours...';

            // Get the user's answers from the current form state
            const userAnswers = {};
             questionsContainer.querySelectorAll('.mb-8').forEach(questionElement => {
                 const index = parseInt(questionElement.getAttribute('data-question-index'));
                 const selectedInputs = questionElement.querySelectorAll(`input[name="q${index}"]:checked`);
                 if (selectedInputs.length > 0) {
                    if (questions[index].type === 'trueFalse') {
                        // Store as boolean true/false
                        userAnswers[index] = selectedInputs[0].value === 'true';
                    } else { // multiple choice
                        // Store as array of numbers
                        userAnswers[index] = Array.from(selectedInputs).map(input => parseInt(input.value));
                    }
                 }
             });


            const score = calculateScore(userAnswers);
            const userData = JSON.parse(localStorage.getItem('examUser'));

             if (!userData || !userData.pseudo || !userData.pin) {
                 alert("Erreur de session : Veuillez vous reconnecter.");
                 showLogin(); // Send back to login if user data is missing
                  // Re-enable button before returning
                 submitExamButton.disabled = false;
                 submitExamButton.textContent = 'Soumettre l\'examen';
                 return;
             }

            try {
                // Check if pseudo already has a result submitted in Firebase *again* before submitting
                 const existingResultQuery = query(examResultsCollection, where('pseudo', '==', userData.pseudo), limit(1));
                 const existingResultSnapshot = await getDocs(existingResultQuery);

                 if (!existingResultSnapshot.empty) {
                     alert(`Un résultat existe déjà pour le pseudo "${userData.pseudo}". Votre examen précédent a déjà été enregistré.`);
                 } else {
                     // Save results to Firebase
                     await addDoc(examResultsCollection, {
                         pseudo: userData.pseudo,
                         pin: userData.pin, // Optionally save PIN
                         score: score,
                         userAnswers: userAnswers, // Save user's answers for correction
                         timestamp: serverTimestamp() // Use server timestamp
                     });

                    alert(`Votre examen a été soumis avec succès ! Votre score est de ${score}/${questions.length}.`);

                    // Clear local storage for this exam's answers after successful submission
                    localStorage.removeItem('examAnswers');
                     // Keep examUser in local storage for results phase
                 }


            } catch (error) {
                console.error("Erreur lors de la soumission de l'examen:", error);
                alert("Une erreur est survenue lors de la soumission de l'examen. Veuillez vérifier votre connexion. Si le problème persiste, notez votre score et contactez l'organisateur.");
                 // Don't clear local storage in case of Firebase error, user might retry or inspect locally.
                 // Re-enable the button.
                 submitExamButton.disabled = false;
                 submitExamButton.textContent = 'Soumettre l\'examen';
                 return; // Stop here if Firebase submission failed
            }

            // Transition to waiting for results screen
            if (now < RESULTS_TIME) {
                 showWaitingForResults();
            } else {
                 // If already after results time, show results directly
                 showResults();
            }
             // Button is re-enabled only in the catch block if there was an error,
             // otherwise the page state changes.
        }


        // --- Results Logic ---
        async function updateLeaderboard() {
            try {
                 // Order by score descending, then timestamp ascending (for ties)
                const snapshot = await getDocs(query(examResultsCollection, orderBy('score', 'desc'), orderBy('timestamp', 'asc')));
                leaderboardListElement.innerHTML = ''; // Clear current list

                if (snapshot.empty) {
                    leaderboardListElement.innerHTML = '<div class="text-center p-4 text-muted-foreground">Aucun résultat disponible pour le moment.</div>';
                } else {
                    snapshot.forEach((doc, index) => {
                        const data = doc.data();
                        const item = document.createElement('div');
                        item.className = 'leaderboard-item';
                        // Add timestamp if needed for debugging ties: data.timestamp?.toDate().toLocaleString()
                        item.innerHTML = `
                            <span>${index + 1}. ${data.pseudo}</span>
                            <span>${data.score}/${questions.length}</span>
                        `;
                        leaderboardListElement.appendChild(item);
                    });
                }
            } catch (error) {
                 console.error("Error fetching leaderboard:", error);
                 leaderboardListElement.innerHTML = '<div class="text-center p-4 text-muted-foreground">Erreur lors du chargement du classement.</div>';
            }
        }

         async function updateSubmittedCount() {
             try {
                  // Count documents in examResults collection
                  const snapshot = await getDocs(examResultsCollection);
                  submittedCountElement.textContent = snapshot.size;
             } catch (error) {
                  console.error("Error fetching submitted count:", error);
                  submittedCountElement.textContent = 'N/A';
             }
         }


         function displayCorrection(userAnswers, isGenericView = false) {
             correctionListElement.innerHTML = ''; // Clear previous correction
             const correctionTitleElement = correctionSectionElement.querySelector('h3');

             if (isGenericView) {
                 correctionTitleElement.textContent = 'Correction des Questions';
             } else {
                 correctionTitleElement.textContent = 'Votre Correction';
             }
             correctionSectionElement.classList.remove('hidden'); // Show the correction section


             questions.forEach((q, index) => {
                 const userAnswer = userAnswers ? userAnswers[index] : undefined;
                 const isAnswered = userAnswer !== undefined;

                 let userAnswerText = ''; // Will be populated only if not generic and answered
                 if (!isGenericView && isAnswered) {
                     if (q.type === 'trueFalse') {
                         userAnswerText = userAnswer ? 'Vrai' : 'Faux';
                     } else if (Array.isArray(userAnswer)) {
                         const selectedOptionsText = userAnswer.sort().map(i => {
                             if (q.options && q.options[i] !== undefined) {
                                return q.options[i];
                             } else {
                                 return `Option Index ${i}`;
                             }
                         });
                         userAnswerText = selectedOptionsText.length > 0 ? selectedOptionsText.join(', ') : 'Aucune option sélectionnée';
                     } else {
                          userAnswerText = 'Format de réponse inattendu';
                     }
                 }

                 let correctAnswerText;
                 if (q.type === 'trueFalse') {
                     correctAnswerText = q.answer ? 'Vrai' : 'Faux';
                 } else {
                     const correctOptionsText = q.answer.sort().map(i => {
                         if (q.options && q.options[i] !== undefined) {
                                return q.options[i];
                            } else {
                                return `Option Index ${i}`;
                            }
                     });
                     correctAnswerText = correctOptionsText.join(', ');
                 }

                 let singleQuestionScore = 0;
                 if (!isGenericView && isAnswered) { // Only calculate score if it's a user's correction and they answered
                    singleQuestionScore = calculateScore({[index]: userAnswer});
                 }
                 const isCorrect = !isGenericView && isAnswered && singleQuestionScore === 1;

                 const correctionItem = document.createElement('div');
                 correctionItem.className = 'correction-item';

                 let userAnswerLine = '';
                 if (!isGenericView) {
                     if (isAnswered) {
                         userAnswerLine = `<br><span class="user-answer ${isCorrect ? 'correct' : ''}">Votre réponse: ${userAnswerText}</span>`;
                     } else {
                         userAnswerLine = `<br><span class="user-answer">Vous n'avez pas répondu</span>`;
                     }
                 }

                 correctionItem.innerHTML = `
                     <div class="font-bold">Question ${index + 1}</div>
                     <div class="question-text">${q.text}</div>
                     <div class="text-sm mt-1">
                         <span class="correct-answer">Correcte: ${correctAnswerText}</span>
                         ${userAnswerLine}
                     </div>
                 `;
                 correctionListElement.appendChild(correctionItem);
             });
         }


        // --- Theme Toggle ---
        const themeToggle = document.getElementById('themeToggle');
        const body = document.body;

        themeToggle.addEventListener('click', () => {
            body.classList.toggle('dark');
            const icon = themeToggle.querySelector('i');
            icon.classList.toggle('fa-moon');
            icon.classList.toggle('fa-sun');
            localStorage.setItem('theme', body.classList.contains('dark') ? 'dark' : 'light');
        });

        // Load saved theme on startup
        function loadTheme() {
             if (localStorage.getItem('theme') === 'dark') {
                 body.classList.add('dark');
                 themeToggle.querySelector('i').classList.replace('fa-moon', 'fa-sun');
             }
        }


        // --- Initialization on Page Load ---
        window.addEventListener('load', async () => {
            loadTheme(); // Apply saved theme
            await initializeRegisteredCounter(); // Ensure counter exists
             startRegisteredCounterListener(); // Start listening to registered count immediately


            // Check user state and time immediately on load
            const savedUser = localStorage.getItem('examUser');
            const now = getAlgeriaTime();

            if (now >= RESULTS_TIME) {
                // If after results time, show results directly
                showResults();
            } else if (now >= EXAM_END_TIME && now < RESULTS_TIME) {
                 // If after exam but before results, show waiting for results
                 showWaitingForResults(); // This will start the results countdown
            } else if (now >= EXAM_START_TIME && now < EXAM_END_TIME) {
                 // If during exam time
                 if(savedUser) {
                      // If logged in, start the exam
                      const userData = JSON.parse(savedUser);
                      startExam(userData); // This will start the exam timer and load answers
                 } else {
                      // Not logged in, show login screen indicating exam is live
                      showLogin(); // This will start the global countdown showing "Examen en cours"
                 }
            } else { // Before exam start time
                 if(savedUser) {
                     // If logged in, show waiting screen
                     const userData = JSON.parse(savedUser);
                     showWaitingForExam(userData.pseudo);
                     startExamStartCountdown(); // Start countdown to exam start
                 } else {
                     // Not logged in, show login screen with countdown to start
                     showLogin(); // This will start the global countdown showing time to start
                 }
            }

             // Start the main global countdown loop only if it's not already running
             // and it's before the results time. It's primarily used on the login page.
             if (!globalCountdownInterval && now < RESULTS_TIME) {
                 globalCountdownInterval = setInterval(updateGlobalCountdown, 1000);
             }

        });

         // Clean up intervals and Firebase listeners when the window is closed or navigated away
         window.addEventListener('beforeunload', () => {
             clearAllIntervals();
             // Unsubscribe Firebase listeners
             stopRegisteredCounterListener();
             // Attempt to save current answers one last time if in exam
             if (!examSection.classList.contains('hidden')) {
                  saveAnswers();
             }
         });
    </script>
</body>
</html>