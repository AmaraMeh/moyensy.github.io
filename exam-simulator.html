<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Simulateur d'Examen - Informatique 2</title>
    <meta name="description" content="Simulateur d'examen pour la révision des étudiants en Informatique 2">
    <meta name="author" content="Votre Nom">
    <link rel="icon" type="image/png" href="assets/img/icon.png">
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&family=Roboto+Mono:wght@400;500;700&display=swap" rel="stylesheet">

    <!-- Vercel Analytics -->
    <script>
        window.va = window.va || function () { (window.vaq = window.vaq || []).push(arguments); };
    </script>
    <script defer src="/_vercel/insights/script.js"></script>

    <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-SQ0WWSCS7B"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-SQ0WWSCS7B');
    </script>

    <style>
        :root {
            --background: 0 0% 100%;
            --foreground: 222.2 84% 4.9%;
            --card: 0 0% 100%;
            --card-foreground: 222.2 84% 4.9%;
            --primary: 221.2 83.2% 53.3%; /* Bleu vif */
            --primary-foreground: 210 40% 98%; /* Blanc cassé */
            --secondary: 210 40% 96.1%; /* Gris clair */
            --secondary-foreground: 222.2 47.4% 11.2%; /* Gris foncé */
            --muted: 210 40% 96.1%;
            --muted-foreground: 215.4 16.3% 46.9%;
            --accent: 210 40% 96.1%;
            --accent-foreground: 222.2 47.4% 11.2%;
            --border: 214.3 31.8% 91.4%; /* Bordure gris clair */
            --input: 214.3 31.8% 91.4%;
            --ring: 221.2 83.2% 53.3%;

            /* Custom colors for correction */
            --correct-color: 145 63% 42%; /* Vert */
            --incorrect-color: 350 80% 50%; /* Rouge */
             --manual-color: 38 92% 50%; /* Jaune orangé */ /* Couleur pour correction manuelle */
        }

        .dark {
            --background: 222.2 84% 4.9%;
            --foreground: 210 40% 98%;
            --card: 222.2 84% 4.9%;
            --card-foreground: 210 40% 98%;
            --primary: 217.2 91.2% 59.8%; /* Bleu plus clair */
            --primary-foreground: 222.2 47.4% 11.2%;
            --secondary: 217.2 32.6% 17.5%;
            --secondary-foreground: 210 40% 98%;
            --muted: 217.2 32.6% 17.5%;
            --muted-foreground: 215 20.2% 65.1%;
            --accent: 217.2 32.6% 17.5%;
            --accent-foreground: 210 40% 98%;
            --border: 217.2 32.6% 17.5%;
            --input: 217.2 32.6% 17.5%;
            --ring: 224.3 76.3% 48%;

             /* Custom colors for correction in dark mode */
            --correct-color: 145 58% 55%; /* Vert */
            --incorrect-color: 350 70% 65%; /* Lighter Red */
            --manual-color: 48 92% 60%; /* Jaune orangé */ /* Couleur pour correction manuelle */
        }

        body {
            font-family: 'Poppins', sans-serif;
            background: hsl(var(--background));
            color: hsl(var(--foreground));
            min-height: 100vh;
            -webkit-tap-highlight-color: transparent;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        .exam-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 1rem; /* Adjusted padding for better mobile fit */
        }

        .exam-card {
            background: hsl(var(--card));
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            padding: 1.5rem; /* Adjusted padding */
            margin-bottom: 1.5rem; /* Adjusted margin */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        .timer {
            font-size: 1.25rem; /* Slightly smaller on mobile */
            font-weight: bold;
            color: hsl(var(--primary));
            text-align: center;
            margin: 1rem 0;
        }
         @media (min-width: 640px) { /* Apply larger size on small screens and up */
             .timer {
                 font-size: 1.5rem;
             }
         }

        .question-container {
            margin: 1.5rem 0; /* Adjusted margin */
        }

        .option {
            display: flex;
            align-items: center;
            width: 100%;
            padding: 0.75rem; /* Adjusted padding */
            margin: 0.4rem 0; /* Adjusted margin */
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            background: hsl(var(--card));
            cursor: pointer;
            transition: all 0.3s ease;
            gap: 0.6rem; /* Adjusted gap */
             /* Prevent text selection on options */
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
        }

        .option:hover:not(.disabled-option) { /* Hover effect only if not disabled */
            background: hsl(var(--accent));
            border-color: hsl(var(--primary));
        }
         .option.disabled-option { /* Style for disabled options in correction */
             cursor: default;
             opacity: 0.8;
         }


        .option input[type="radio"],
        .option input[type="checkbox"] {
            margin-right: 0;
            width: 1.1rem; /* Slightly smaller on mobile */
            height: 1.1rem; /* Slightly smaller on mobile */
            flex-shrink: 0;
             cursor: pointer; /* Keep cursor pointer on the input itself */
        }
         .option.disabled-option input[type="radio"],
         .option.disabled-option input[type="checkbox"] {
             cursor: default;
         }

         @media (min-width: 640px) {
             .option input[type="radio"],
             .option input[type="checkbox"] {
                  width: 1.2rem;
                  height: 1.2rem;
             }
         }


         /* Style for selected options */
        .option input[type="radio"]:checked + span,
        .option input[type="checkbox"]:checked + span {
             color: hsl(var(--primary-foreground));
        }

        .option input[type="radio"]:checked,
        .option input[type="checkbox"]:checked {
             accent-color: hsl(var(--primary));
        }

         /* Custom class for selected options background */
        .option.selected-option {
            background: hsl(var(--primary));
            color: hsl(var(--primary-foreground));
            border-color: hsl(var(--primary));
        }
        .option.selected-option input[type="radio"],
        .option.selected-option input[type="checkbox"] {
             accent-color: hsl(var(--primary-foreground));
        }

         /* Correction styles for options */
         .option.correct {
             background: hsl(var(--correct-color));
             color: white; /* Or a light foreground color */
             border-color: hsl(var(--correct-color));
         }
         .option.incorrect.selected-option { /* User selected, but it was wrong */
             background: hsl(var(--incorrect-color));
             color: white; /* Or a light foreground color */
             border-color: hsl(var(--incorrect-color));
         }
          .option.correct input[type="radio"],
          .option.correct input[type="checkbox"],
          .option.incorrect.selected-option input[type="radio"],
          .option.incorrect.selected-option input[type="checkbox"] {
              accent-color: white; /* Or a light foreground color */
          }


        .theme-toggle, .logout-button {
            position: fixed;
            bottom: 1rem;
            padding: 0.75rem;
            border-radius: 50%;
            background: hsl(var(--primary));
            color: hsl(var(--primary-foreground));
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 50; /* Ensure they are on top */
            border: none; /* Ensure no default button border */
        }
         .theme-toggle {
             right: 1rem;
         }
         .logout-button {
             left: 1rem;
             background: hsl(var(--secondary)); /* Use secondary color for distinction */
             color: hsl(var(--secondary-foreground));
         }
          .logout-button:hover:not(:disabled) {
              background: hsl(var(--secondary-foreground));
              color: hsl(var(--secondary));
          }


        .theme-toggle:hover:not(:disabled), .logout-button:hover:not(:disabled) {
            transform: scale(1.1);
        }
         .theme-toggle:disabled, .logout-button:disabled {
             cursor: not-allowed;
             opacity: 0.8;
         }


        .login-form {
            max-width: 400px;
            margin: 1.5rem auto; /* Adjusted margin */
            padding: 1.5rem; /* Adjusted padding */
            background: hsl(var(--card));
            border-radius: var(--radius);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); /* Ajusté */
            text-align: center;
        }

        .form-input {
            width: 100%;
            padding: 0.75rem;
            margin: 0.5rem 0;
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            background: hsl(var(--input));
            color: hsl(var(--foreground));
        }

        .btn {
            display: inline-block;
            padding: 0.75rem 1.5rem;
            background: hsl(var(--primary));
            color: hsl(var(--primary-foreground));
            border-radius: var(--radius);
            cursor: pointer;
            transition: all 0.3s ease;
            border: none;
            font-weight: 500;
            text-align: center;
            width: auto; /* Default width */
        }
         .btn.w-full { /* Use w-full class explicitly for full width */
             width: 100%;
         }


        .btn:hover:not(:disabled) { /* Apply hover effect only if not disabled */
            opacity: 0.9;
            transform: translateY(-1px);
        }

        .btn:disabled {
            background-color: hsl(var(--muted));
            color: hsl(var(--muted-foreground));
            cursor: not-allowed;
            transform: none;
            opacity: 0.8;
        }


        .leaderboard {
            margin-top: 1.5rem; /* Adjusted margin */
        }

        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem; /* Adjusted padding */
            border-bottom: 1px solid hsl(var(--border));
        }

        .leaderboard-item:last-child {
            border-bottom: none;
        }

        .stats-card {
            background: hsl(var(--card));
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            padding: 1rem;
            margin: 1rem 0;
            text-align: center;
        }

        .stats-number {
            font-size: 1.75rem; /* Slightly smaller */
            font-weight: bold;
            color: hsl(var(--primary));
        }
         @media (min-width: 640px) {
              .stats-number {
                 font-size: 2rem;
              }
         }
        .score-detail {
            font-size: 0.9rem;
            color: hsl(var(--muted-foreground));
            margin-top: 0.5rem;
        }


        .question-number {
            font-weight: bold;
            color: hsl(var(--primary));
            margin-bottom: 0.5rem;
        }
         .question-points {
             font-size: 0.9em;
             font-weight: normal;
             color: hsl(var(--muted-foreground));
             margin-left: 0.5em;
         }


        .question-text {
            margin-bottom: 0.75rem; /* Adjusted margin */
        }

        .options-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); /* Adjusted min width for mobile */
            gap: 0.75rem; /* Adjusted gap */
            margin: 1rem 0;
        }

        .checkbox-option {
            display: flex; /* Ensure flexibility */
            align-items: center; /* Vertical alignment */
            gap: 0.5rem; /* Space between checkbox and text */
        }

         /* Code Input Area */
         .code-input {
            width: 100%;
            padding: 0.75rem;
            margin-top: 1rem;
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            background: hsl(var(--input));
            color: hsl(var(--foreground));
            font-family: 'Roboto Mono', monospace; /* Monospaced font for code */
            font-size: 0.9rem;
            resize: vertical; /* Allow vertical resizing */
             tab-size: 4; /* Standard tab size */
         }
         .code-input::placeholder {
             color: hsl(var(--muted-foreground));
             opacity: 1;
         }


         /* Deroulement Table */
         .deroulement-table {
             width: 100%;
             border-collapse: collapse; /* Remove space between borders */
             margin-top: 1rem;
             font-family: 'Roboto Mono', monospace; /* Monospaced font for table data */
             font-size: 0.85rem; /* Slightly smaller font */
         }
         .deroulement-table th,
         .deroulement-table td {
             border: 1px solid hsl(var(--border));
             padding: 0.5rem; /* Adjusted padding */
             text-align: left;
             vertical-align: top;
         }
         .deroulement-table th {
             background: hsl(var(--secondary));
             font-weight: bold;
         }
         .deroulement-table td input[type="text"] {
             width: 100%;
             padding: 0.2rem;
             border: none; /* Remove input border */
             background: transparent; /* Transparent background */
             color: hsl(var(--foreground));
             font-family: 'Roboto Mono', monospace;
             font-size: 0.85rem;
         }
         .deroulement-table td input[type="text"]:focus {
             outline: 1px solid hsl(var(--primary)); /* Highlight on focus */
             background: hsl(var(--accent)); /* Slight background on focus */
         }
          /* Specific width for the Instruction column */
          .deroulement-table thead th:first-child,
          .deroulement-table tbody td:first-child {
              width: 20%; /* Allocate more space for instruction */
              min-width: 120px; /* Minimum width */
              white-space: normal; /* Allow wrapping */
          }

         /* Text Input Area */
         .text-input {
            width: 100%;
            padding: 0.75rem;
            margin-top: 1rem;
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            background: hsl(var(--input));
            color: hsl(var(--foreground));
            font-family: 'Poppins', sans-serif; /* Standard font for text answer */
            font-size: 0.9rem;
            resize: vertical;
         }
         .text-input::placeholder {
             color: hsl(var(--muted-foreground));
             opacity: 1;
         }


        .progress-bar {
            width: 100%;
            height: 0.5rem;
            background: hsl(var(--muted));
            border-radius: var(--radius);
            overflow: hidden;
            margin: 1rem 0;
        }

        .progress-fill {
            height: 100%;
            background: hsl(var(--primary));
            transition: width 0.3s ease;
        }


        .rules-container {
            background: hsl(var(--card));
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            padding: 1.5rem; /* Adjusted padding */
            margin: 1.5rem 0; /* Adjusted margin */
        }

        .rules-title {
            font-size: 1.25rem; /* Adjusted size */
            font-weight: bold;
            margin-bottom: 1rem;
            color: hsl(var(--primary));
        }
         @media (min-width: 640px) {
             .rules-title {
                 font-size: 1.5rem;
             }
         }


        .rules-list {
            list-style-type: disc;
            padding-left: 1.25rem; /* Adjusted padding */
            margin: 1rem 0;
            font-size: 0.95rem; /* Slightly smaller text */
        }

        .rules-list li {
            margin: 0.4rem 0; /* Adjusted margin */
        }

        /* Correction Section Styles */
        .correction-item {
             border-bottom: 1px solid hsl(var(--border));
             padding: 1rem 0;
        }
         .correction-item:last-child {
             border-bottom: none;
         }
         .correction-item .question-text {
             margin-bottom: 0.5rem;
             font-weight: 500;
         }

         /* Styles for text-based correction (MC/TF/TextInput) */
         .correction-item .text-correction .correct-answer {
             color: hsl(var(--correct-color));
             font-weight: bold;
             font-size: 0.9rem;
             margin-top: 0.5rem;
         }
         .correction-item .text-correction .user-answer {
             color: hsl(var(--incorrect-color));
             font-weight: bold;
             font-size: 0.9rem;
             margin-top: 0.2rem;
         }
         .correction-item .text-correction .user-answer.correct {
             color: hsl(var(--correct-color));
         }
          .correction-item .text-correction .user-answer.unanswered {
              color: hsl(var(--muted-foreground));
              font-weight: normal;
              font-style: italic; /* Indicate unanswered visually */
          }

         /* Styles for code correction */
         .correction-item .code-correction pre {
             background: hsl(var(--muted));
             border: 1px solid hsl(var(--border));
             border-radius: var(--radius);
             padding: 0.75rem;
             margin-top: 0.5rem;
             overflow-x: auto; /* Scroll for long lines */
             font-family: 'Roboto Mono', monospace;
             font-size: 0.85rem;
             white-space: pre-wrap; /* Wrap long lines */
             word-wrap: break-word;
         }
         .correction-item .code-correction .user-code {
             border-color: hsl(var(--manual-color)); /* Highlight user code container */
         }
          .correction-item .code-correction .text-muted-foreground {
              font-family: 'Poppins', sans-serif; /* Use standard font for messages */
          }

         /* Styles for deroulement correction */
         .correction-item .deroulement-correction .table-container {
            max-width: 100%; /* Ensure table container respects parent width */
         }
         .correction-item .deroulement-correction .user-table td input[type="text"],
         .correction-item .deroulement-correction .correct-table td input[type="text"] {
              /* Remove hover/focus effects in correction view */
             pointer-events: none;
             cursor: default;
             background: transparent !important;
             outline: none !important;
         }
          .correction-item .deroulement-correction .user-table {
              border-color: hsl(var(--manual-color)); /* Highlight user table */
          }
          .correction-item .deroulement-correction .user-table td,
           .correction-item .deroulement-correction .correct-table td {
               font-size: 0.85rem; /* Match input size */
               min-width: 50px; /* Prevent extreme squishing */
               white-space: pre-wrap; /* Allow wrapping in correction */
                word-wrap: break-word;
           }
            .correction-item .deroulement-correction .user-table th,
            .correction-item .deroulement-correction .correct-table th {
                 font-size: 0.85rem;
            }

         .correction-item .manual-grade-note {
             font-size: 0.85rem;
             color: hsl(var(--manual-color));
             margin-top: 0.75rem;
             font-weight: 500;
         }


    </style>
</head>
<body>
    <div class="exam-container">
         <!-- Logout Button (Fixed position) -->
         <button id="logoutBtn" class="logout-button hidden" title="Déconnexion">
            <i class="fas fa-sign-out-alt"></i>
         </button>

    <!-- Login Section -->
    <div id="loginSection" class="login-form">
        <h2 class="text-2xl font-bold mb-4">Simulateur d'Examen</h2>
        <p class="text-lg mb-4">Informatique 2</p>

        <div class="rules-container text-left">
            <div class="rules-title">Règlement de l'examen simulé</div>
            <ul class="rules-list">
                 <li>L'examen est disponible **24h/24, 7j/7**.</li>
                <li>Une fois l'examen démarré, vous disposez de **1h30** pour le compléter.</li>
                <li>L'examen comporte **7 questions** couvrant différents aspects d'Informatique 2.</li>
                <li>Barème total : **20 points**. Les points par question sont indiqués.</li>
                 <li>Les questions de cours (QCM/VF) sont notées automatiquement. Les questions de code, de déroulement et de réponse courte nécessitent une **correction manuelle** pour l'attribution des points correspondants.</li>
                <li>Votre score calculé automatiquement (sur les QCM/VF) et la correction détaillée pour **toutes** les questions seront affichés **immédiatement après la soumission**.</li>
                <li>Vos réponses sont sauvegardées localement dans votre navigateur pendant la session active (1h30).</li>
                <li>Vous ne pouvez soumettre l'examen **qu'une seule fois** par pseudo.</li>
            </ul>
        </div>

        <div class="stats-card">
            <div class="stats-number" id="registeredCount">0</div>
            <div>Participants enregistrés (total)</div>
        </div>

        <form id="loginForm">
            <input type="text" id="pseudo" class="form-input" placeholder="Pseudo" required>
            <input type="password" id="pin" class="form-input" placeholder="Code PIN (4 chiffres)" pattern="[0-9]{4}" maxlength="4" required>
            <button type="submit" id="loginButton" class="btn w-full mt-4">Commencer l'examen</button>
        </form>
    </div>

    <!-- Exam Section -->
    <div id="examSection" class="exam-card hidden">
        <div class="flex flex-col sm:flex-row justify-between items-center mb-4">
            <div class="timer mb-4 sm:mb-0" id="timer">01:30:00</div>
            <div class="stats-card w-full sm:w-auto">
                 {/* La progression affichera Questions répondues / Total Questions */}
                <div class="stats-number" id="questionProgress">0/0</div>
                <div>Questions répondues</div>
            </div>
        </div>
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill" style="width: 0%"></div>
        </div>
        <form id="examForm">
             <div id="questionsContainer" class="question-container">
                 {/* Questions will be dynamically added here */}
             </div>
            <button type="submit" id="submitExam" class="btn w-full mt-4">Soumettre l'examen</button>
        </form>
    </div>

    <!-- Results Section -->
    <div id="resultsSection" class="exam-card hidden">
        <h2 class="text-2xl font-bold mb-4">Résultats et Classement</h2>

        <!-- User Result Summary (Shown if logged in and result found) -->
        <div id="userResultSummary" class="mb-6 hidden">
            <div class="stats-card">
                 {/* Le score affichera le score calculé automatiquement / score total possible */}
                <div class="stats-number" id="userScore">--/20</div>
                 <div class="score-detail">(Score calculé automatiquement sur les QCM/VF)</div>
                <div>Votre score</div>
            </div>
            {/* Correction is now always shown for logged-in user if result is found */}
        </div>

        <div class="stats-card">
            <div class="stats-number" id="submittedCount">0</div>
            <div>Participants ayant soumis</div>
        </div>

        {/* Correction Section (Moved above leaderboard) */}
         <div id="correctionSection" class="correction-section mt-4 mb-8 hidden">
             <h3 class="text-xl font-bold mb-4" id="correctionTitle">Votre Correction</h3>
             <div id="correctionList">
                 {/* Correction will be dynamically added here */}
             </div>
         </div>

        <div class="leaderboard">
            <h3 class="text-xl font-bold mb-2">Classement (Score automatique)</h3> {/* Précision sur le classement */}
            <div id="leaderboardList">
                {/* Leaderboard will be dynamically added here */}
                 <div class="text-center p-4 text-muted-foreground">Chargement du classement...</div>
            </div>
             <div class="text-sm text-muted-foreground mt-4 text-center">
                 Le classement est basé sur le score calculé automatiquement (QCM/VF). Les questions de code, de déroulement et de réponse courte nécessitent une correction manuelle.
             </div>
        </div>
    </div>
</div>

<button id="themeToggle" class="theme-toggle" title="Changer de thème">
    <i class="fas fa-moon"></i>
</button>


<!-- Firebase SDK (Modular style using gstatic URLs) -->
<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js";
    import { getFirestore, doc, getDoc, setDoc, collection, addDoc, getDocs, query, orderBy, limit, serverTimestamp, onSnapshot, where, increment } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js";
    // Supprimez l'import de date-fns car le timer de début est retiré
    // import { formatDistanceToNowStrict } from "https://cdn.skypack.dev/date-fns@2.29.3"; // Pour formater le temps restant


    // Your web app's Firebase configuration (replace with your actual config)
    // Utilisez la même config que votre site
    const firebaseConfig = {
        apiKey: "AIzaSyB5XYqWKhHdiVDXJx4iOwtpxD8eUCPRfKU",
        authDomain: "universite-de-bejaia-547fc.firebaseapp.com",
        databaseURL: "https://universite-de-bejaia-547fc-default-rtdb.europe-west1.firebasedatabase.app",
        projectId: "universite-de-bejaia-547fc",
        storageBucket: "universite-de-bejaia-547fc.firebaseapp.com", // Correction: .firebaseapp.com
        messagingSenderId: "517622731583",
        appId: "1:517622731583:web:25453d5e01226585bf798a",
        measurementId: "G-SQ0WWSCS7B"
    };


    // Initialize Firebase
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    // Helper function to get current time (using local time for session start/end calculations)
    // Note: Firebase timestamp is used for submission time, ensuring consistency.
    function getClientTime() {
        return new Date();
    }

    // Supprimez la date de début d'examen
    // const EXAM_START_DATE = new Date('2024-05-21T13:30:00');

    // Exam Duration (1 hour 30 minutes)
    const SESSION_DURATION_MS = 90 * 60 * 1000;

    // UI Elements
    const loginSection = document.getElementById('loginSection');
    const examSection = document.getElementById('examSection');
    const resultsSection = document.getElementById('resultsSection');

    // Supprimez les éléments du timer de début
    // const startTimerMessageElement = document.getElementById('startTimerMessage');
    // const startTimerElement = document.getElementById('startTimer');
    const loginForm = document.getElementById('loginForm');
    const loginButton = document.getElementById('loginButton');

    const examTimerElement = document.getElementById('timer');

    const pseudoInput = document.getElementById('pseudo');
    const pinInput = document.getElementById('pin');
    const registeredCountElement = document.getElementById('registeredCount');
    const submittedCountElement = document.getElementById('submittedCount');

    const questionsContainer = document.getElementById('questionsContainer');
    const questionProgressElement = document.getElementById('questionProgress');
    const progressFillElement = document.getElementById('progressFill');
    const submitExamButton = document.getElementById('submitExam');

    const userResultSummaryElement = document.getElementById('userResultSummary');
    const userScoreElement = document.getElementById('userScore');
    const leaderboardListElement = document.getElementById('leaderboardList');
    const correctionSectionElement = document.getElementById('correctionSection');
    const correctionListElement = document.getElementById('correctionList');
    const correctionTitleElement = document.getElementById('correctionTitle');
    const logoutBtn = document.getElementById('logoutBtn');


    // Questions data (Informatique 2) - Total 20 points
    const questions = [
        // Questions de cours (QCM) - Total 4.5 points (Répartis en 3 questions)
        {
            id: 'q-cours-1-diff-params',
            type: 'multiple',
            text: 'Quelle est la différence fondamentale entre un paramètre passé **par valeur** et un paramètre passé **par variable** (référence) lors de l\'appel d\'un sous-programme ?',
            options: [
                'Par valeur : Une copie de la valeur est transmise. Les modifications dans le sous-programme n\'affectent pas la variable d\'origine.',
                'Par variable (référence) : L\'adresse mémoire de la variable est transmise (mot-clé VAR). Les modifications dans le sous-programme affectent la variable d\'origine.',
                'Par valeur : L\'adresse mémoire est transmise. Les modifications affectent la variable d\'origine.',
                'Par variable : Une copie est créée. Les modifications n\'affectent pas la variable d\'origine.',
                'Il n\'y a aucune différence entre les deux types de passage de paramètres.'
            ],
            answer: [0, 1], // Les deux premières options sont correctes
            points: 1.5
        },
        {
            id: 'q-cours-2-diff-func-proc',
            type: 'multiple',
            text: 'Expliquez la différence entre une **Fonction** et une **Procédure** en termes de leur utilisation et de ce qu\'elles renvoient.',
            options: [
                'Fonction : Effectue un calcul et retourne une seule valeur via son nom. Est utilisée dans une expression ou une affectation.',
                'Procédure : Exécute une série d\'actions. Ne retourne pas de valeur via son nom (peut utiliser VAR). Est appelée comme une instruction.',
                'Fonction : Ne peut pas retourner de valeur.',
                'Procédure : Doit toujours retourner une valeur.',
                'Il n\'y a aucune différence entre une fonction et une procédure.'
            ],
            answer: [0, 1], // Les deux premières options sont correctes
            points: 1.5
        },
        {
            id: 'q-cours-3-declare-record',
            type: 'multiple',
            text: 'Comment déclare-t-on un type **enregistrement (Record)** en Pascal ? Donnez un exemple simple.',
            options: [
                'TYPE\n  NomTypeEnregistrement = RECORD\n    NomChamp1 : TypeChamp1 ;\n    NomChamp2 : TypeChamp2 ;\n    (* ... autres champs *)\n  END;',
                'TYPE\n  Personne = RECORD\n    Nom : String[50];\n    Age : Integer;\n    Salaire : Real;\n  END;',
                'RECORD\n  NomTypeEnregistrement = TYPE\n    NomChamp1 : TypeChamp1 ;\n    NomChamp2 : TypeChamp2 ;\n  END;',
                'TYPE\n  NomTypeEnregistrement : RECORD\n    NomChamp1 = TypeChamp1 ;\n    NomChamp2 = TypeChamp2 ;\n  END;',
                'TYPE\n  NomTypeEnregistrement\n    RECORD\n      NomChamp1 : TypeChamp1 ;\n      NomChamp2 : TypeChamp2 ;\n    END;'
            ],
            answer: [0, 1], // Les deux premières options sont correctes
            points: 1.5
        },


        // Exercice 01 : [7 points]
        // Partie A, Q1: Traduction Algo -> Pascal (Traitement) - Total 2 points
        {
            id: 'q-exo1-1-code',
            type: 'codeWrite',
            text: 'Traduisez la partie **Traitement** de l\'algorithme "TraitementVecteur" ci-dessous en code Pascal. Complétez les cases vides dans le code fourni.',
            algorithmCode: `Algorithme TraitementVecteur;
Variables
  V : Tableau[1..50] de Entier ;
  N, i, Count : Entier ;
Début
  // Entrées (ne pas traduire cette partie)
  ...

  // Traitement
  Count <-- 0 ;
  Pour i <-- 1 à N Faire
    Si (V[i] > 10 ET V[i] MOD 2 <> 0) Alors
      Count <-- Count + 1 ;
    FinSi ;
  FinPour ;

  // Sortie (ne pas traduire cette partie)
  ...
Fin.`,
            correctCode: `(* Déclarations de variables pour la partie Traitement *)
Var
  V : Array[1..50] of Integer; (* Assumons V est déclaré et rempli ailleurs *)
  N : Integer; (* Assumons N est déclaré et lu ailleurs *)
  i, Count : Integer;

(* Bloc Traitement *)
Begin
  [1] := 0;  (* Initialisation de Count *)
  For [2] := 1 to [3] do
    If ([4] > 10) and ([5] mod 2 <> 0) Then
      [6] := [7] + 1;
  (* Fin Traitement *)
End.`,
            codeHints: [
                "Count",
                "i",
                "N",
                "V[i]",
                "V[i]",
                "Count",
                "Count"
            ],
            points: 2
        },
        // Partie A, Q2: Déduction - Total 1 point (ajusté de 0.5 à 1)
        {
            id: 'q-exo1-3-deduction',
            type: 'textInput',
            text: 'Déduisez ce que fait l\'algorithme "TraitementVecteur" (Exercice 1).',
            correctAnswer: 'L\'algorithme compte le nombre d\'éléments du vecteur V qui sont strictement supérieurs à 10 ET impairs.',
            points: 1
        },
        // Partie A, Q3: Transformation de Boucle - Total 1.5 points
        {
            id: 'q-exo1-4-loop',
            type: 'codeWrite',
            text: 'Reecrivez la partie **Traitement** de l\'algorithme "TraitementVecteur" en remplacant la boucle `Pour` par une boucle **`Repeter...Jusqu\'a` (Repeat...Until)**. Complétez les cases vides dans le code fourni.',
            algorithmCode: "// Traitement (original)\n" +
                "Count <-- 0;\n" +
                "Pour i <-- 1 \u00e0 N Faire;\n" +
                "  Si (V[i] > 10 ET V[i] MOD 2 <> 0) Alors;\n" +
                "    Count <-- Count + 1;\n" +
                "  FinSi;\n" +
                "FinPour;",
            correctCode: `(* Déclarations de variables pour la partie Traitement *)
Var
  V : Array[1..50] of Integer; (* Assumons V est déclaré et rempli *)
  N : Integer; (* Assumons N est déclaré et lu *)
  i, Count : Integer;

(* Bloc Traitement avec Répéter...Jusqu'à *)
Begin
  [1] := 0;  (* Initialisation de Count *)
  [2] := 1;  (* Initialisation de i *)
  If [3] > 0 Then
  Repeat
    If ([4] > 10) and ([5] mod 2 <> 0) Then
      [6] := [7] + 1;
    [8] := [9] + 1;  (* Incrémentation de i *)
  Until [10] > [11];  (* Condition d'arrêt *)
  (* Fin Traitement *)
End.`,
            codeHints: [
                "Count",
                "i",
                "N",
                "V[i]",
                "V[i]",
                "Count",
                "Count",
                "i",
                "i",
                "i",
                "N"
            ],
            points: 1.5
        },


        // Exercice 02 : [8 points]
        {
            id: 'q-exo2-1-code',
            type: 'codeWrite',
            text: 'Soit une matrice carrée `M` d\'ordre `N` (N lignes, N colonnes) contenant des nombres `Réel`. Complétez le programme PASCAL suivant pour :\n1. Lire la taille `N` de la matrice et ses éléments (2 pts) :\n   - Lecture de N : 0.5 pt\n   - Lecture des éléments : 1.5 pt\n2. Calculer la somme des éléments de la **diagonale principale** de la matrice en utilisant une **Fonction** nommée "SommeDiagPrinc" (2 pts) :\n   - Initialisation de Somme : 0.5 pt\n   - Boucle et accumulation : 1 pt\n   - Retour de la somme : 0.5 pt\n3. Modifier la matrice en multipliant par 2 **tous** les éléments situés **au-dessus** de la diagonale principale, en utilisant une **Procédure** nommée "ModifierMatrice" (3 pts) :\n   - Boucles imbriquées : 1 pt\n   - Condition pour éléments au-dessus de la diagonale : 1 pt\n   - Multiplication par 2 : 1 pt\n4. Afficher la matrice modifiée (1 pt) :\n   - Boucles d\'affichage : 1 pt\n\nNote : Des points partiels seront attribués pour chaque partie correctement implémentée.',
            correctCode: `Program MatriceOperations;
Const MAX_SIZE = 10;
Type MatriceType = Array[1..MAX_SIZE, 1..MAX_SIZE] of Real;

// Fonction pour calculer la somme de la diagonale principale
Function SommeDiagPrinc(M : MatriceType; N : Integer) : Real;
Var
  i : Integer;
  Somme : Real;
Begin
  [1] := 0.0;  (* Initialisation de Somme - 0.5 pt *)
  For i := 1 to [2] do
    [3] := [4] + [5];  (* Accumulation de la somme - 1 pt *)
  [6] := [7];  (* Retour de la somme - 0.5 pt *)
End;

// Procédure pour modifier les éléments au-dessus de la diagonale
Procedure ModifierMatrice(Var M : MatriceType; N : Integer);
Var
  i, j : Integer;
Begin
  For i := 1 to [8] do  (* Boucles imbriquées - 1 pt *)
    For j := 1 to [9] do
    Begin
      If [10] < [11] Then  (* Condition pour éléments au-dessus de la diagonale - 1 pt *)
        M[i, j] := [12] * 2.0;  (* Multiplication par 2 - 1 pt *)
    End;
End;

// Programme Principal
Var
  MaMatrice : MatriceType;
  TailleN, i, j : Integer;
  ResultatSomme : Real;

Begin
  // 1. Lire la taille N et les éléments de la matrice (2 pts)
  Write('Donner la taille N de la matrice (max ', MAX_SIZE, ') : ');
  ReadLn([13]);  (* Lecture de N - 0.5 pt *)

  WriteLn('Donner les elements de la matrice :');
  For i := 1 to [14] do  (* Lecture des éléments - 1.5 pts *)
    Begin
      For j := 1 to [15] do
        Read([16]);
      ReadLn;
    End;

  // 2. Calculer la somme de la diagonale principale
  [17] := [18]([19], [20]);

  // Afficher le résultat de la fonction
  WriteLn('La somme des elements de la diagonale principale est : ', [21]:0:2);

  // 3. Modifier la matrice
  [22]([23], [24]);

  // 4. Afficher la matrice modifiée (1 pt)
  WriteLn('La matrice modifiee est :');
  For i := 1 to [25] do  (* Affichage - 1 pt *)
    Begin
      For j := 1 to [26] do
        Write([27]:6:2, ' ');
      WriteLn;
    End;

  ReadLn;
End.`,
            codeHints: [
                "Somme",
                "N",
                "Somme",
                "Somme",
                "M[i, i]",
                "SommeDiagPrinc",
                "Somme",
                "N",
                "N",
                "i",
                "j",
                "M[i, j]",
                "TailleN",
                "TailleN",
                "TailleN",
                "MaMatrice[i, j]",
                "ResultatSomme",
                "SommeDiagPrinc",
                "MaMatrice",
                "TailleN",
                "ResultatSomme",
                "ModifierMatrice",
                "MaMatrice",
                "TailleN",
                "TailleN",
                "TailleN",
                "MaMatrice[i, j]"
            ],
            points: 8
        }
        // Total points: 1.5 + 1.5 + 1.5 (Cours) + 2 + 3 + 0.5 + 1.5 (Exo1) + 8 (Exo2) = 4.5 + 7 + 8 = 19.5 points.
        // Ajustons pour arriver à 20. Donnons 1 point à la déduction (0.5 -> 1). Total: 4.5 + 7.5 + 8 = 20. Ok.
        // Réajustement final des points pour Exo1: Traduction 2, Déroulement 3, Déduction 1, Loop Transform 1. Total Exo1 = 7.
        // Réajustement final des points pour Exo2: Programme complet (Lecture 2, Func 2, Proc 3, Appels/Affich 1). Total Exo2 = 8.
        // Total : 4.5 + 7 + 8 = 19.5. Ah, le barème original était 4.5 + 7 + 8.5 = 20. Re-vérifions Exo2 points originaux.
        // Exo2 points originaux: Lecture 1.5, Func 3, Proc 3, Affichage 1. Total 1.5+3+3+1 = 8.5.
        // D'accord, les points de l'énoncé original Exo2 étaient déjà 8.5. Donc Total = 4.5 + 7 + 8.5 = 20.
        // Utilisons les points originaux de l'énoncé : Cours 4.5, Exo1 7, Exo2 8.5.
        // Exo1: Traduction 2, Déroulement 3, Déduction 0.5, Loop Transform 1.5. Total 2+3+0.5+1.5 = 7. Correct.
        // Exo2: Programme Complet (Lecture 1.5, Func 3, Proc 3, Affichage 1). Total 1.5+3+3+1 = 8.5. Correct.
        // Total final: 4.5 + 7 + 8.5 = 20. PARFAIT. Utilisons ces points.

        // Mise à jour des points dans les questions correspondantes (textInput, codeWrite, deroulement)
        // Les points sont déjà corrects dans les définitions des questions ci-dessus. Le total final est 20.
    ];


    // Total points possible = Sum of points from all questions
    // Cette variable est correcte car elle calcule la somme des points définis dans chaque question.
    const TOTAL_POSSIBLE_POINTS = questions.reduce((sum, q) => sum + q.points, 0);


    // --- Firebase Counters ---
    // Changer les noms pour Informatique 2
    const registeredCounterRef = doc(db, 'counters', 'informatique2_registered');
    const examResultsCollection = collection(db, 'examResults_informatique2');


    // Initialize counter if it doesn't exist
    const initializeRegisteredCounter = async () => {
        try {
            const counterDoc = await getDoc(registeredCounterRef);
            if (!counterDoc.exists()) {
                // Ensure the initial count is 0 if the document doesn't exist
                await setDoc(registeredCounterRef, { count: 0 });
            }
        } catch (error) {
            console.error("Error initializing registered counter:", error);
        }
    };

    // Listen for real-time updates to the registered counter
    let unsubscribeRegisteredCounter = null;
    const startRegisteredCounterListener = () => {
         // Prevent starting multiple listeners
         if (unsubscribeRegisteredCounter === null) {
             unsubscribeRegisteredCounter = onSnapshot(registeredCounterRef, (doc) => {
                 if (doc.exists()) {
                     // Update the count if the document exists
                     registeredCountElement.textContent = doc.data().count;
                 } else {
                      // If the counter document somehow disappears, display 0
                     registeredCountElement.textContent = '0';
                 }
             }, (error) => {
                 console.error("Error listening to registered counter:", error);
                 registeredCountElement.textContent = 'Erreur'; // Indicate error in UI
             });
         }
    };
    const stopRegisteredCounterListener = () => {
         if (unsubscribeRegisteredCounter) {
             unsubscribeRegisteredCounter();
             unsubscribeRegisteredCounter = null; // Reset the variable
         }
    };

    // --- Timer Logic (Per Session) ---
    let examTimerInterval = null;
    let sessionStartTime = null; // Stored locally in localStorage
    const localStorageStartTimeKey = 'examStartTime_informatique2'; // Consistent key for local storage
    const localStorageUserKey = 'examUser_informatique2'; // Consistent key for local storage
    const localStorageAnswersKey = 'examAnswers_informatique2'; // Consistent key for local storage


    function formatTime(ms) {
        if (ms < 0) ms = 0;
        const totalSeconds = Math.floor(ms / 1000);
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;
        return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }

     function startExamTimer() {
         // Ensure we stop any existing timer first
         stopExamTimer();

         // Load session start time from localStorage
         const savedStartTimeStr = localStorage.getItem(localStorageStartTimeKey);

         if (!savedStartTimeStr) {
             // Session start time not found -> THIS IS THE START of the 1h30 session
             console.log("No saved session start time found in localStorage. Starting a new 1h30 timer.");
             sessionStartTime = getClientTime().getTime(); // Get current time as start time
             localStorage.setItem(localStorageStartTimeKey, sessionStartTime.toString()); // Save the new start time
         } else {
             // Session start time IS found -> Resume the timer from that point
             console.log("Saved session start time found in localStorage. Resuming timer.");
             sessionStartTime = parseInt(savedStartTimeStr); // Parse the saved start time
         }

         const now = getClientTime().getTime();
         let remainingTimeMs = SESSION_DURATION_MS - (now - sessionStartTime); // Calculate remaining time

         if (remainingTimeMs <= 0) {
             // Time already up or expired
             examTimerElement.textContent = "00:00:00";
             console.log("Time already expired. Submitting exam automatically.");
             // Use a small timeout to allow UI update before submit
             setTimeout(submitExam, 50); // Automatically submit
             return;
         }

         examTimerElement.textContent = formatTime(remainingTimeMs); // Display initial remaining time

         // Start the interval to update the timer every second
         examTimerInterval = setInterval(() => {
             remainingTimeMs -= 1000; // Decrease by 1 second

             if (remainingTimeMs <= 0) {
                 clearInterval(examTimerInterval); // Stop the interval
                 examTimerInterval = null;
                 examTimerElement.textContent = "00:00:00"; // Display 0 time
                 console.log("Timer reached zero. Submitting exam automatically.");
                 submitExam(); // Time's up, submit
                 alert("Votre temps est écoulé ! L'examen a été soumis automatiquement.");
                 return;
             }

             examTimerElement.textContent = formatTime(remainingTimeMs); // Update display
         }, 1000); // Update every 1000ms (1 second)
     }


    function stopExamTimer() {
         if (examTimerInterval) {
             clearInterval(examTimerInterval); // Clear the interval
             examTimerInterval = null; // Reset the variable
         }
    }


    // --- UI State Management ---
    function hideAllSections() {
        loginSection.classList.add('hidden');
        examSection.classList.add('hidden');
        resultsSection.classList.add('hidden');
        logoutBtn.classList.add('hidden');
    }

    function showLogin() {
         hideAllSections();
         loginSection.classList.remove('hidden');
         logoutBtn.classList.add('hidden'); // Hide logout button on login page

         stopExamTimer(); // Ensure exam timer is stopped if user navigates back to login
         startRegisteredCounterListener(); // Listen for registered count on login page

         // Login form is always visible now
         loginForm.classList.remove('hidden');
         loginButton.disabled = false; // Ensure login button is enabled
    }

    function startExam(userData) {
        hideAllSections();
        examSection.classList.remove('hidden');
        logoutBtn.classList.remove('hidden'); // Show logout during exam

        displayQuestions(); // Render questions on the page
        loadSavedAnswers(); // Load any saved answers from local storage into the displayed form
        updateProgress(); // Update the progress bar based on loaded/current answers
        startExamTimer(); // Start the countdown timer based on session start time (or start a new one if none saved)

        stopRegisteredCounterListener(); // Stop listener during exam to avoid unnecessary updates
    }

    async function showResults(userData = null) {
        hideAllSections();
        resultsSection.classList.remove('hidden');
        logoutBtn.classList.remove('hidden'); // Show logout on results page

        stopExamTimer(); // Ensure exam timer is stopped
        startRegisteredCounterListener(); // Listen for registered count on results page (shown on results page)

        // Clear previous content in the results section
        userResultSummaryElement.classList.add('hidden');
        correctionListElement.innerHTML = '';
        correctionSectionElement.classList.add('hidden');
        leaderboardListElement.innerHTML = '<div class="text-center p-4 text-muted-foreground">Chargement du classement...</div>';

        let userResult = null;
        let userCalculatedScore = '--'; // Score from Firebase for leaderboard/summary


        // Check if we have user data and pseudo to fetch their specific result
        if (userData && userData.pseudo) {
            try {
                // Fetch the submitted result for the logged-in user based on pseudo
                const userResultQuery = query(examResultsCollection, where('pseudo', '==', userData.pseudo), limit(1));
                const userResultSnapshot = await getDocs(userResultQuery);

                if (!userResultSnapshot.empty) {
                    userResult = userResultSnapshot.docs[0].data(); // Get the document data
                    userCalculatedScore = userResult.score; // Use the automatic score stored in Firebase

                    // Display the user's score summary
                    userResultSummaryElement.innerHTML = `
                        <div class="stats-card">
                            <div class="stats-number">${userCalculatedScore}/${TOTAL_POSSIBLE_POINTS}</div>
                            <div class="score-detail">(Score calculé automatiquement sur les QCM/VF)</div>
                            <div>Votre score</div>
                        </div>
                    `;
                    userResultSummaryElement.classList.remove('hidden');
                    // Display personalized correction using the saved userAnswers
                    displayCorrection(userResult.userAnswers, false);
                } else {
                    // Logged in but no result found in DB for this pseudo (e.g., session expired, manual clear)
                    userResultSummaryElement.innerHTML = `<div class="stats-card"><p>Aucun résultat soumis trouvé pour "${userData.pseudo}".</p></div>`;
                    userResultSummaryElement.classList.remove('hidden');
                     // Display generic correction as no user answers were saved to DB for this pseudo
                    displayCorrection(null, true); // Pass null userAnswers to show generic
                }
            } catch (error) {
                console.error("Error fetching user result:", error);
                userResultSummaryElement.innerHTML = `<div class="stats-card"><p>Erreur lors du chargement de vos résultats.</p></div>`;
                userResultSummaryElement.classList.remove('hidden');
                // Display generic correction on error fetching
                displayCorrection(null, true); // Pass null userAnswers
            }
        } else {
             // Not logged in or invalid userData, show generic correction and leaderboard
             displayCorrection(null, true); // Pass null userAnswers
        }

        // Update general stats (submitted count) and leaderboard for everyone
        await updateSubmittedCount();
        await updateLeaderboard();
    }

    // Checks Firebase if a submission exists for a given pseudo
    async function checkExistingSubmission(pseudo) {
        if (!pseudo) return false; // Cannot check without a pseudo
        try {
            // Query the examResults collection for a document where the 'pseudo' field matches the given pseudo
            const existingResultQuery = query(examResultsCollection, where('pseudo', '==', pseudo), limit(1)); // Limit to 1 as we only need to know if ANY exist
            const existingResultSnapshot = await getDocs(existingResultQuery); // Execute the query
            return !existingResultSnapshot.empty; // Returns true if documents are found (submission exists), false otherwise
        } catch (error) {
            console.error("Error checking for existing submission:", error);
            // In case of error, it's safer to assume no existing submission to avoid blocking the user,
            // but log the error. Firebase rules should ideally prevent duplicate writes for the same pseudo.
            // For this simulation, let's allow proceeding but the submit function will also check again.
            alert("Erreur de connexion lors de la vérification de votre pseudo. Veuillez réessayer si nécessaire.");
            return false; // Assume no existing submission if check fails
        }
    }


    // --- Login Functionality ---
    // This function is triggered when the login form is submitted.
    loginForm.addEventListener('submit', async (e) => {
        e.preventDefault(); // Prevent the default form submission and page reload
        console.log("Login form submitted"); // Debug log

        const pseudo = pseudoInput.value.trim(); // Get the pseudo from the input, remove leading/trailing whitespace
        const pin = pinInput.value; // Get the PIN from the input
        console.log("Pseudo:", pseudo, "PIN:", pin); // Debug log

        // Basic validation for pseudo and PIN
        if (!pseudo) {
            alert("Veuillez entrer un Pseudo.");
            return; // Stop the function if validation fails
        }
        if (!/^[0-9]{4}$/.test(pin)) { // Use regex to check if PIN is exactly 4 digits
            alert("Le Code PIN doit être composé de 4 chiffres.");
            return; // Stop the function if validation fails
        }

        // Check if a submission already exists for this pseudo in Firebase
        console.log("Checking for existing submission..."); // Debug log
        const existingSubmission = await checkExistingSubmission(pseudo);
        console.log("Existing submission check result:", existingSubmission); // Debug log

        if (existingSubmission) {
            // If a submission is found, alert the user and redirect them to the results page
            alert(`Un résultat existe déjà pour le pseudo "${pseudo}". Vous ne pouvez soumettre l'examen qu'une seule fois.`);
            // Store the user data locally so the results page can fetch their submission
            const userData = { pseudo: pseudo, pin: pin }; // Only need pseudo for fetching results
            localStorage.setItem(localStorageUserKey, JSON.stringify(userData));
            showResults(userData); // Show results for this specific user
            return; // Stop the function to prevent starting the exam
        }

        // If no existing submission is found:
        console.log("No existing submission, proceeding with exam start"); // Debug log
        // Store the user data locally
        const userData = { pseudo: pseudo, pin: pin };
        localStorage.setItem(localStorageUserKey, JSON.stringify(userData));
        // Set the session start time to the current time. This begins the 1h30 timer.
        const startTime = getClientTime().getTime(); // Get current time in milliseconds
        localStorage.setItem(localStorageStartTimeKey, startTime.toString()); // Save it as a string

        // Increment the participant counter in Firebase
        // This is a simple counter, might not be perfectly accurate under heavy load but sufficient for a sim.
        try {
            console.log("Incrementing registered counter..."); // Debug log
            await setDoc(registeredCounterRef, { count: increment(1) }, { merge: true }); // Increment by 1, merge ensures other fields aren't overwritten
            console.log("Counter incremented successfully"); // Debug log
        } catch (error) {
            console.error("Error incrementing registered counter:", error);
            // Continue the flow even if the counter update fails
        }

        // Start the exam UI
        console.log("Starting exam UI..."); // Debug log
        startExam(userData); // Pass user data to the startExam function
        console.log("Exam UI started"); // Debug log
    });

    // --- Logout Functionality ---
    // This function is triggered when the logout button is clicked.
    logoutBtn.addEventListener('click', handleLogout);

    function handleLogout() {
        // Check if the user is currently in the exam section
        const inExam = !examSection.classList.contains('hidden');

        // Show a confirmation message based on the current state (in exam or not)
        if (inExam) {
            if (!confirm("Vous êtes en train de passer l'examen. Si vous vous déconnectez, votre progression locale sera perdue et votre examen ne sera pas soumis. Voulez-vous continuer la déconnexion ?")) {
                return; // If the user clicks 'Cancel', stop the function
            }
            // If the user confirms during the exam, answers are saved locally by the input change listener just before the page unloads (handled by window.addEventListener('beforeunload'))
        } else {
            // If not in exam, just ask for a general confirmation
            if (!confirm("Voulez-vous vraiment vous déconnecter ?")) {
                return; // If the user clicks 'Cancel', stop the function
            }
        }

        // Clear all local storage data related to THIS exam session/user
        localStorage.removeItem(localStorageUserKey); // Remove user data
        localStorage.removeItem(localStorageAnswersKey); // Remove saved answers
        localStorage.removeItem(localStorageStartTimeKey); // Remove session start time

        // Stop any active timers and Firebase listeners
        stopExamTimer(); // Stop the exam countdown timer
        stopRegisteredCounterListener(); // Stop the live counter listener

        // Transition back to the login page
        showLogin();
        // Display a confirmation message
        alert("Vous avez été déconnecté.");
    }


    // --- Exam Logic: Displaying Questions ---
    function displayQuestions() {
        questionsContainer.innerHTML = ''; // Clear any previously displayed questions
        questions.forEach((question, index) => { // Iterate through the questions array
            const questionElement = document.createElement('div');
            questionElement.className = 'mb-8 exam-question'; // Add base classes
            questionElement.setAttribute('data-question-index', index); // Store the question's index
            questionElement.setAttribute('data-question-type', question.type); // Store the question's type
            questionElement.setAttribute('data-question-id', question.id); // Store the question's unique ID


            let questionContent = ''; // String to build the HTML content for this question

            // Add Question Number and Points
            questionContent += `<div class="question-number">Question ${index + 1} <span class="question-points">(${question.points} pts)</span></div>`;
            // Add Question Text
            questionContent += `<div class="question-text">${question.text}</div>`;


            // Add Input Area based on Question Type
            if (question.type === 'trueFalse' || question.type === 'multiple') {
                questionContent += `
                    <div class="options-grid">
                        ${question.options.map((option, optIndex) => {
                           const inputType = question.type === 'trueFalse' ? 'radio' : 'checkbox';
                           const inputName = `q${index}`;
                           let inputValue = optIndex;
                           if (question.type === 'trueFalse') {
                               inputValue = option === 'Vrai' ? 'true' : 'false';
                           }

                            return `
                                <label class="option ${question.type === 'multiple' ? 'checkbox-option' : ''}" data-q="${index}" data-value="${inputValue}">
                                    <input type="${inputType}" name="${inputName}" value="${inputValue}" ${question.type === 'trueFalse' ? 'required' : ''}>
                                    <span>${option}</span>
                                </label>
                            `;
                        }).join('')}
                    </div>
                `;
            } else if (question.type === 'codeWrite') {
                 questionContent += `
                     ${question.algorithmCode ? `
                        <div class="font-semibold mt-2 mb-1">Algorithme source :</div>
                        <pre class="bg-gray-100 dark:bg-gray-800 p-4 rounded-md mb-4 overflow-x-auto text-sm">${question.algorithmCode.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</pre>` : ''}
                     <textarea class="code-input" data-q-index="${index}" rows="15" placeholder="Écrivez votre code Pascal ici..." spellcheck="false" autocorrect="off" autocapitalize="off"></textarea>
                 `;
            } else if (question.type === 'deroulement') {
                 questionContent += `
                     ${question.inputDescription ? `<p class="text-sm text-muted-foreground mb-2">Valeurs d'entrée : ${question.inputDescription}</p>` : ''}
                      ${question.algorithmCode ? `
                         <div class="font-semibold mt-2 mb-1">Extrait d'algorithme :</div>
                         <pre class="bg-gray-100 dark:bg-gray-800 p-4 rounded-md mb-4 overflow-x-auto text-sm">${question.algorithmCode.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</pre>` : ''}

                     <p class="mb-2">Complétez le tableau de déroulement :</p>
                     <div class="table-container overflow-x-auto">
                         <table class="deroulement-table">
                            <thead>
                                <tr>
                                    ${question.tableHeaders.map(header => `<th>${header}</th>`).join('')}
                                </tr>
                            </thead>
                            <tbody>
                                ${question.traceSteps.map((step, rowIndex) => `
                                    <tr>
                                        <td>${step.Instruction}</td>
                                        ${question.tableHeaders.slice(1).map((header, colIndex) => `
                                            <td>
                                                <input type="text" data-q-index="${index}" data-row="${rowIndex}" data-col="${colIndex}">
                                            </td>
                                        `).join('')}
                                    </tr>
                                `).join('')}
                            </tbody>
                         </table>
                     </div>
                 `;
            } else if (question.type === 'textInput') {
                 questionContent += `
                     <textarea class="text-input" data-q-index="${index}" rows="5" placeholder="Écrivez votre réponse ici..." spellcheck="false" autocorrect="off" autocapitalize="off"></textarea>
                 `;
            }


            questionElement.innerHTML = questionContent; // Set the generated HTML as the content of the question element
            questionsContainer.appendChild(questionElement); // Add the question element to the container
        });

        // Add event listeners for answer selection and input to save and update progress
        // Remove old listeners first to avoid duplicates if displayQuestions is called again (e.g., after a local storage error)
        questionsContainer.removeEventListener('change', handleAnswerChange);
        questionsContainer.removeEventListener('input', handleAnswerChange);
        // Add new listeners
        questionsContainer.addEventListener('change', handleAnswerChange); // Listen for radio/checkbox changes
        questionsContainer.addEventListener('input', handleAnswerChange); // Listen for text input/textarea input (input event fires more frequently than change)
    }


    // Handles changes to input fields within the questions container
    function handleAnswerChange(e) {
        const input = e.target; // The specific input element that changed
        // Check if the change/input is from a relevant field type
        if (input.matches('input[type="radio"], input[type="checkbox"], textarea.code-input, .deroulement-table input[type="text"], textarea.text-input')) {
            saveAnswers(); // Save ALL answers to local storage whenever a relevant input changes
            updateProgress(); // Update the progress bar based on the current state of answers
            // Only update visual selected class for options (radio/checkbox)
            if (input.matches('input[type="radio"], input[type="checkbox"]')) {
                 updateOptionClasses(); // Update the background/color of selected options
            }
        }
    }

    // Updates the visual class for selected radio/checkbox options
    function updateOptionClasses() {
        // Select all question elements that are MC or TF
        questionsContainer.querySelectorAll('.exam-question[data-question-type="trueFalse"], .exam-question[data-question-type="multiple"]').forEach(questionElement => {
            const options = questionElement.querySelectorAll('.option'); // Get all option labels within the question
            options.forEach(label => {
                const input = label.querySelector('input'); // Get the input inside the label
                // If the input exists and is checked, add the 'selected-option' class
                if (input && input.checked) {
                    label.classList.add('selected-option');
                } else {
                    // Otherwise, ensure the 'selected-option' class is removed
                    label.classList.remove('selected-option');
                }
            });
        });
    }


    // Saves the current state of user answers from the form into local storage
    function saveAnswers() {
        const answers = {}; // Object to store answers, keyed by question index
        questions.forEach((question, index) => { // Iterate through the defined questions
             // Find the corresponding question element on the page
             const questionElement = questionsContainer.querySelector(`.exam-question[data-question-index="${index}"]`);
             // If the question element is found (means we are in the exam view)
             if (questionElement) {
                 if (question.type === 'trueFalse' || question.type === 'multiple') {
                     // Find all checked radio/checkbox inputs for this question
                     const selectedInputs = questionElement.querySelectorAll(`input[name="q${index}"]:checked`);
                     if (selectedInputs.length > 0) {
                         if (question.type === 'trueFalse') {
                             // For TF, save the string value ('true' or 'false') of the checked radio
                             answers[index] = selectedInputs[0].value; // Save as string
                         } else { // multiple choice
                             // For MC, save an array of the integer values (indices) of checked checkboxes
                             answers[index] = Array.from(selectedInputs).map(input => parseInt(input.value)); // Save as array of numbers
                         }
                     }
                     // If no inputs are checked, the key answers[index] will not be set, indicating unanswered.
                 } else if (question.type === 'codeWrite' || question.type === 'textInput') {
                      // Find the textarea for this question
                      const textarea = questionElement.querySelector('textarea');
                      // If the textarea exists and has content (trimming whitespace)
                      if (textarea && textarea.value.trim() !== '') {
                          answers[index] = textarea.value; // Save the text content as a string
                      }
                 } else if (question.type === 'deroulement') {
                      // Find all text inputs within the deroulement table for this question
                      const tableInputs = questionElement.querySelectorAll('.deroulement-table input[type="text"]');
                      const tableData = {}; // Object to store table cell values, keyed by row and column index
                      let isTableAnswered = false; // Flag to check if any cell has content
                      tableInputs.forEach(input => {
                          const row = input.getAttribute('data-row'); // Get the row index from data attribute
                          const col = input.getAttribute('data-col'); // Get the column index from data attribute
                          if (!tableData[row]) {
                              tableData[row] = {}; // Initialize the object for this row if it doesn't exist
                          }
                          tableData[row][col] = input.value; // Store the input value
                          if (input.value.trim() !== '') {
                              isTableAnswered = true; // If any cell has content, mark the question as answered
                          }
                      });
                      // Only save the table data object if at least one cell was filled
                      if (isTableAnswered) {
                          answers[index] = tableData; // Save the table data object
                      }
                 }
             }
        });

        // Save the collected answers object to local storage
        localStorage.setItem(localStorageAnswersKey, JSON.stringify(answers));
        // The session start time is already managed elsewhere, no need to resave it here.
    }


    // Loads saved answers from local storage into the form fields when the exam is resumed
    function loadSavedAnswers() {
        const savedAnswers = localStorage.getItem(localStorageAnswersKey); // Get saved answers string from local storage
        if (savedAnswers) { // Check if saved answers exist
            try {
                const answers = JSON.parse(savedAnswers); // Parse the JSON string back into an object
                 questions.forEach((question, index) => { // Iterate through the defined questions
                    // Find the corresponding question element on the page
                    const questionElement = questionsContainer.querySelector(`.exam-question[data-question-index="${index}"]`);
                     if (!questionElement) return; // Skip if element not found on the page

                    const userAnswer = answers[index]; // Get the saved answer for this specific question index

                    if (userAnswer !== undefined) { // Check if an answer was saved for this question
                        if (question.type === 'trueFalse' || question.type === 'multiple') {
                            if (question.type === 'trueFalse') {
                                // For TF, saved answer is string 'true'/'false'. Select the radio with that value.
                                const input = questionElement.querySelector(`input[name="q${index}"][value="${userAnswer}"][type="radio"]`); // Specify type="radio"
                                if (input) {
                                    input.checked = true;
                                } else {
                                    console.warn(`Could not find radio button for saved TF answer q${index}:`, userAnswer);
                                }
                            } else { // multiple choice
                                // For MC, saved answer is an array of selected indices (numbers)
                                if (Array.isArray(userAnswer)) { // Crucial check: Ensure saved data is an array
                                    userAnswer.forEach(optIndex => {
                                        // Select checkboxes based on saved indices (input value is numeric index)
                                        const input = questionElement.querySelector(`input[name="q${index}"][value="${optIndex}"][type="checkbox"]`); // Specify type="checkbox"
                                        if (input) {
                                            input.checked = true;
                                        } else {
                                             console.warn(`Could not find checkbox for saved MC answer q${index} option ${optIndex}.`);
                                        }
                                    });
                                } else {
                                    console.warn(`Saved answer for q${index} (MC) is not an array, cannot load options:`, userAnswer);
                                }
                            }
                        } else if (question.type === 'codeWrite' || question.type === 'textInput') {
                             // Find the textarea for this question
                             const textarea = questionElement.querySelector('textarea');
                             // For code/text, saved answer is a string.
                             if (textarea && typeof userAnswer === 'string') { // Crucial check: Ensure saved data is a string
                                 textarea.value = userAnswer; // Set the textarea value
                             } else {
                                console.warn(`Saved answer for q${index} (${question.type}) is not a string, cannot load text:`, userAnswer);
                             }
                        } else if (question.type === 'deroulement') {
                             // Find all text inputs within the deroulement table for this question
                             const tableInputs = questionElement.querySelectorAll('.deroulement-table input[type="text"]');
                             // For deroulement, saved answer is an object/map.
                             if (typeof userAnswer === 'object' && userAnswer !== null) { // Crucial check: Ensure saved data is an object
                                 tableInputs.forEach(input => {
                                     const row = input.getAttribute('data-row'); // Get row index
                                     const col = input.getAttribute('data-col'); // Get column index
                                      // Use optional chaining ?. to safely access nested properties in the saved object
                                      // Check if the saved object has the row and the column for that row
                                     if (userAnswer[row]?.[col] !== undefined) { // Check if cell value exists in saved data
                                         input.value = userAnswer[row][col]; // Set the input value
                                     }
                                 });
                             } else {
                                console.warn(`Saved answer for q${index} (Deroulement) is not an object, cannot load table:`, userAnswer);
                             }
                        }
                    }
                });
                updateOptionClasses(); // Apply selected visual style for options after loading
            } catch (e) {
                console.error("Failed to load saved answers from localStorage:", e);
                // If loading fails (e.g., corrupted data), clear the corrupted data from local storage
                localStorage.removeItem(localStorageAnswersKey);
                localStorage.removeItem(localStorageStartTimeKey); // Also clear start time as the answers are gone
                alert("Erreur: Impossible de charger vos réponses sauvegardées localement. Vous recommencerez un nouvel examen.");
                // Note: The timer might continue running if it was already started and not expired.
                // The next login attempt or page reload will handle state correctly based on empty local storage.
            }
        }
    }


    // Updates the question progress counter and the progress bar
    function updateProgress() {
        let answeredCount = 0; // Counter for answered questions
         // Iterate through the defined questions to check if they are answered
         questions.forEach((question, index) => {
             // Find the corresponding question element on the page
             const questionElement = questionsContainer.querySelector(`.exam-question[data-question-index="${index}"]`);
              if (!questionElement) return; // Skip if the question element isn't currently displayed (shouldn't happen in exam state)

             let isQuestionAnswered = false; // Flag for the current question
             if (question.type === 'trueFalse' || question.type === 'multiple') {
                 // For MC/TF, consider answered if at least one option is checked
                 const selectedInputs = questionElement.querySelectorAll(`input[name="q${index}"]:checked`);
                 if (selectedInputs.length > 0) {
                     isQuestionAnswered = true;
                 }
             } else if (question.type === 'codeWrite' || question.type === 'textInput') {
                  // For code/text input, consider answered if the textarea has non-whitespace content
                  const textarea = questionElement.querySelector('textarea');
                  if (textarea && textarea.value.trim() !== '') {
                      isQuestionAnswered = true;
                  }
             } else if (question.type === 'deroulement') {
                  // For deroulement, consider answered if at least one cell input has non-whitespace content
                  const tableInputs = questionElement.querySelectorAll('.deroulement-table input[type="text"]');
                  for (const input of tableInputs) {
                      if (input.value.trim() !== '') {
                          isQuestionAnswered = true;
                          break; // Found at least one input, no need to check others for this question
                      }
                  }
             }

             if (isQuestionAnswered) {
                 answeredCount++; // Increment the counter if the question is answered
             }
         });

        // Update the text display of answered questions out of total
        questionProgressElement.textContent = `${answeredCount}/${questions.length}`;
        // Calculate and update the width of the progress bar fill
        const progressPercentage = questions.length > 0 ? (answeredCount / questions.length) * 100 : 0;
        progressFillElement.style.width = `${progressPercentage}%`;
    }


    // Calculates the score based ONLY on automatically graded questions (MC/TF)
    function calculateAutomaticScore(userAnswersObject) {
        let score = 0; // Initialize score
        questions.forEach((question, index) => { // Iterate through defined questions
            // Only process questions that are automatically graded
            if (question.type === 'trueFalse' || question.type === 'multiple') {
                 // Safely access the user's answer for this question index
                 const userAnswer = userAnswersObject?.[index];

                 // If the question was not answered, score is 0 for this question (handled by not adding points)
                 if (userAnswer === undefined) {
                     return; // Skip to the next question
                 }

                 if (question.type === 'trueFalse') {
                     // User answer is string 'true'/'false'. Correct answer is boolean true/false.
                     // Compare the user's string answer with the boolean correct answer converted to string.
                     if (userAnswer === String(question.answer)) {
                         score += question.points; // Add points if correct
                     }
                 } else if (question.type === 'multiple') {
                     // User answer is expected to be an array of indices. Correct answer is an array of indices.
                     // CRITICAL FIX: Ensure userAnswer is an array before comparing or sorting.
                     if (Array.isArray(userAnswer)) {
                         // Sort both the correct and submitted answer arrays for reliable comparison
                         const correctAnswersIndices = Array.isArray(question.answer) ? question.answer.slice().sort() : []; // Ensure correct answer is array
                         const submittedAnswersIndices = userAnswer.slice().sort(); // User answer is already checked as array

                          // Check if the number of selected options matches AND all selected options are correct.
                          // This is the logic for "all correct options must be selected, and no incorrect options must be selected".
                          if (submittedAnswersIndices.length === correctAnswersIndices.length &&
                              submittedAnswersIndices.every((val, i) => val === correctAnswersIndices[i])) {
                             score += question.points; // Add points if the arrays match exactly
                         }
                     } else {
                         // If user answer exists but is not an array for MC, it's considered incorrect. Score remains 0.
                         console.warn(`User answer for q${index} (MC) is not an array, counted as incorrect:`, userAnswer);
                     }
                 }
            }
             // Code, Deroulement, and TextInput questions are NOT included in the automatic score calculation.
        });
        return score; // Return the total automatic score
    }


    // Event listener for the exam form submission
    document.getElementById('examForm').addEventListener('submit', async (e) => {
        e.preventDefault(); // Prevent default browser form submission
        await submitExam(); // Call the async submitExam function
    });


    // Handles the exam submission process
    async function submitExam() {
        // Prevent multiple submissions if button is clicked rapidly
        if (submitExamButton.disabled) {
             return;
        }
        submitExamButton.disabled = true; // Disable the button
        submitExamButton.textContent = 'Soumission en cours...'; // Update button text

        // Ensure the latest answers from the form are saved to local storage
        saveAnswers();
        // Get the saved answers from local storage (including Code/Deroulement/TextInput)
        const userAnswers = JSON.parse(localStorage.getItem(localStorageAnswersKey)) || {}; // Default to empty object if nothing saved

        // Calculate the automatic score (only MC/TF)
        const automaticScore = calculateAutomaticScore(userAnswers);

        // Get user data (pseudo/pin) from local storage
        const userData = JSON.parse(localStorage.getItem(localStorageUserKey));

        // Basic check that user data exists before submitting
        if (!userData || !userData.pseudo) {
            console.error("User data or pseudo missing during submission.");
            alert("Erreur de session : Pseudo non trouvé. Veuillez vous reconnecter.");
            showLogin(); // Redirect to login
            // Re-enable button? No, redirecting.
            return;
        }

        try {
            // Perform a final check for existing submission in the database
            // This helps prevent duplicates if the user manages to start the exam again somehow.
            const existingSubmission = await checkExistingSubmission(userData.pseudo);

            if (existingSubmission) {
                // If a submission already exists for this pseudo
                alert(`Un résultat existe déjà pour le pseudo "${userData.pseudo}". Vous ne pouvez soumettre l'examen qu'une seule fois.`);
                // Redirect to results page for this user (fetch their existing result)
                showResults({ pseudo: userData.pseudo });
            } else {
                // If no existing submission, save the results to Firebase
                // Use addDoc to create a new document with a unique auto-generated ID
                await addDoc(examResultsCollection, {
                    pseudo: userData.pseudo, // Save the pseudo for identification
                    // pin: userData.pin, // Optionally save PIN if needed for admin, but not for user auth here
                    score: automaticScore, // Save the AUTOMATIC score for leaderboard ranking
                    userAnswers: userAnswers, // Save the complete set of user answers (including manual ones)
                    timestamp: serverTimestamp() // Save server timestamp for submission time and tie-breaking
                });

                // Alert the user of successful submission
                alert(`Votre examen a été soumis avec succès ! Votre score automatique (QCM/VF) est de ${automaticScore}/${TOTAL_POSSIBLE_POINTS}.`);

                // Clear local storage data related to this exam session after successful submission
                // Clearing user data means they have to log in again for future attempts
                localStorage.removeItem(localStorageUserKey);
                localStorage.removeItem(localStorageAnswersKey);
                localStorage.removeItem(localStorageStartTimeKey);
                stopExamTimer(); // Stop the exam timer

                // Update the submitted count displayed on the results/login page
                await updateSubmittedCount();

                // Transition to the results page for this user (fetch their newly submitted result)
                showResults({ pseudo: userData.pseudo }); // Pass only pseudo needed to fetch result
            }

        } catch (error) {
            // Handle errors during the Firebase write operation
            console.error("Erreur lors de la soumission de l'examen:", error);
            alert("Une erreur est survenue lors de la soumission de l'examen. Veuillez vérifier votre connexion et réessayer. Si le problème persiste, notez votre pseudo et l'heure de soumission, et contactez l'organisateur.");
            // Re-enable the submit button on error so the user can potentially try again
            submitExamButton.disabled = false;
            submitExamButton.textContent = 'Soumettre l\'examen';
            // Do NOT clear local storage here, the user might need to retry submitting the same answers
        }
    }


    // --- Results Logic ---
    // Fetches and displays the leaderboard based on automatic scores
    async function updateLeaderboard() {
        try {
            // Query Firebase for all submitted results
            // Order by score (automatic) descending, then by timestamp ascending (for ties)
            const snapshot = await getDocs(query(examResultsCollection, orderBy('score', 'desc'), orderBy('timestamp', 'asc')));
            leaderboardListElement.innerHTML = ''; // Clear the current leaderboard list

            if (snapshot.empty) {
                // Display message if no results are found
                leaderboardListElement.innerHTML = '<div class="text-center p-4 text-muted-foreground">Aucun résultat disponible pour le moment.</div>';
            } else {
                // Iterate through the documents and create leaderboard items
                snapshot.forEach((doc, index) => {
                    const data = doc.data(); // Get the document data
                    const item = document.createElement('div'); // Create a div for each leaderboard item
                    item.className = 'leaderboard-item'; // Add class for styling
                     // Display rank, pseudo, and automatic score
                    item.innerHTML = `
                        <span>${index + 1}. ${data.pseudo}</span>
                        <span>${data.score}/${TOTAL_POSSIBLE_POINTS}</span>
                    `;
                    leaderboardListElement.appendChild(item); // Add the item to the list
                });
            }
        } catch (error) {
            console.error("Error fetching leaderboard:", error);
            leaderboardListElement.innerHTML = '<div class="text-center p-4 text-muted-foreground">Erreur lors du chargement du classement.</div>'; // Display error message
        }
    }

    // Fetches and displays the total number of submitted exams
    async function updateSubmittedCount() {
        try {
            // Fetch all documents in the examResults collection
            const snapshot = await getDocs(examResultsCollection);
            // Update the submitted count display with the number of documents
            submittedCountElement.textContent = snapshot.size;
        } catch (error) {
            console.error("Error fetching submitted count:", error);
            submittedCountElement.textContent = 'N/A'; // Indicate error
        }
    }


    // Displays the correction for the exam
    // Can display user-specific answers vs correct answers (isGenericView = false)
    // Or just the correct answers (isGenericView = true)
    // Fixes the forEach error by adding Array.isArray checks and optional chaining ?.
    function displayCorrection(userAnswersObject, isGenericView = false) {
        correctionListElement.innerHTML = ''; // Clear previous correction list

        // Set the title of the correction section
        if (isGenericView) {
            correctionTitleElement.textContent = 'Correction de l\'Examen';
        } else {
            correctionTitleElement.textContent = 'Votre Correction';
        }
        correctionSectionElement.classList.remove('hidden'); // Ensure the correction section is visible


        questions.forEach((q, index) => { // Iterate through the defined questions
            // Safely access the user's answer for this question index using optional chaining ?.
            const userAnswer = userAnswersObject?.[index];
            const isAnswered = userAnswer !== undefined; // Flag to indicate if the user provided any answer

            const correctionItem = document.createElement('div'); // Create a div for this question's correction
            correctionItem.className = 'correction-item'; // Add class for styling

            // Add Question Number and Points
            let correctionContent = `<div class="font-bold">Question ${index + 1} <span class="question-points">(${q.points} pts)</span></div>`;
            // Add Question Text
            correctionContent += `<div class="question-text">${q.text}</div>`;

            // Add Correction details based on Question Type
            if (q.type === 'trueFalse' || q.type === 'multiple') {
                 let userAnswerText = '';
                 let isCorrect = false; // Correctness flag (only for automatically graded questions)

                 // If showing user's correction and they answered this question
                 if (!isGenericView && isAnswered) {
                      // Check if the saved answer is the expected type (string for TF, array for MC)
                      if ((q.type === 'trueFalse' && typeof userAnswer === 'string') || (q.type === 'multiple' && Array.isArray(userAnswer))) {
                         // Use a temporary object to calculate the score for this single question
                         const tempUserAnswers = { [index]: userAnswer };
                         const singleQuestionScore = calculateAutomaticScore(tempUserAnswers); // Use automatic score logic
                         isCorrect = (singleQuestionScore === q.points); // Question is correct if the score matches its points
                      }

                     // Format the user's answer text for display
                     if (q.type === 'trueFalse' && typeof userAnswer === 'string') {
                         userAnswerText = userAnswer === 'true' ? 'Vrai' : 'Faux'; // Saved as string 'true'/'false'
                     } else if (q.type === 'multiple' && Array.isArray(userAnswer)) { // CRITICAL FIX: Ensure userAnswer is array before mapping
                         // Map user's selected indices back to option text
                         const selectedOptionsText = userAnswer.map(i => {
                             // Safely access q.options[i] using optional chaining ?.
                             return q.options?.[i] !== undefined ? q.options[i] : `Option invalide (${i})`; // Handle potential invalid indices
                         });
                         userAnswerText = selectedOptionsText.length > 0 ? selectedOptionsText.join(', ') : 'Aucune option sélectionnée';
                     } else {
                          // Handle case where userAnswer exists but isn't the expected type for MC/TF
                          userAnswerText = 'Format de réponse inattendu';
                          isCorrect = false; // Mark as incorrect due to format
                     }
                 }

                 // Get correct answer text for display
                 let correctAnswerText = 'Correction manquante.'; // Default text
                 if (q.type === 'trueFalse' && typeof q.answer === 'boolean') {
                     correctAnswerText = q.answer ? 'Vrai' : 'Faux'; // Correct answer is boolean
                 } else if (q.type === 'multiple' && Array.isArray(q.answer)) { // CRITICAL FIX: Ensure q.answer is array before mapping
                     // Map correct indices back to option text
                     const correctOptionsText = q.answer.map(i => {
                         // Safely access q.options[i]
                         return q.options?.[i] !== undefined ? q.options[i] : `Option correcte inconnue (${i})`; // Handle potential invalid indices
                     });
                     correctAnswerText = correctOptionsText.join(', ');
                 } else if (q.type === 'textInput' && typeof q.correctAnswer === 'string') {
                      correctAnswerText = q.correctAnswer; // For textInput, correct answer is a string
                 }


                 correctionContent += `
                     <div class="text-sm mt-1 text-correction">
                          <span class="correct-answer">Correcte : ${correctAnswerText}</span>
                          ${!isGenericView ? ` {/* Only show user answer if not generic view */}
                              <br><span class="user-answer ${isAnswered ? (isCorrect ? 'correct' : 'incorrect') : 'unanswered'}">Votre réponse : ${isAnswered ? userAnswerText : 'Vous n\'avez pas répondu'}</span>
                          ` : ''}
                     </div>
                 `;

                // Also display the options grid with highlighting in correction view
                if (q.type === 'trueFalse' || q.type === 'multiple') {
                     const optionsGrid = document.createElement('div');
                     optionsGrid.className = 'options-grid mt-2'; // Add a margin top for spacing

                     // Check if q.options is an array before trying to iterate over options
                     if (Array.isArray(q.options)) {
                        q.options.forEach((optionText, optIndex) => {
                             let optionValue;
                             if (q.type === 'trueFalse') {
                                optionValue = (optionText === 'Vrai' ? 'true' : 'false'); // String value for radio
                             } else {
                                optionValue = optIndex; // Numeric index for checkbox
                             }

                             // Determine if this option is a correct answer
                             const isCorrectOption = q.type === 'trueFalse' ? (String(q.answer) === optionValue) : (Array.isArray(q.answer) ? q.answer.includes(optIndex) : false);

                             // Determine if the user selected this option (only if user answer is available and correct type)
                             let isUserSelected = false;
                             if (!isGenericView && isAnswered) { // Check only if user answer is potentially available
                                 if (q.type === 'trueFalse' && typeof userAnswer === 'string') {
                                     isUserSelected = (userAnswer === optionValue);
                                 } else if (q.type === 'multiple' && Array.isArray(userAnswer)) { // Check array before includes
                                      isUserSelected = userAnswer.includes(optIndex);
                                 }
                             }

                             const optionLabel = document.createElement('label');
                             // Add classes for correction styling: disabled, correct, incorrect+selected, selected
                             optionLabel.className = `option disabled-option ${isCorrectOption ? 'correct' : ''} ${isUserSelected && !isCorrectOption ? 'incorrect selected-option' : ''} ${isUserSelected && isCorrectOption ? 'selected-option' : ''}`;
                             optionLabel.innerHTML = `
                                  <input type="${q.type === 'trueFalse' ? 'radio' : 'checkbox'}" disabled ${isUserSelected ? 'checked' : ''}>
                                  <span>${optionText}</span>
                             `;
                             optionsGrid.appendChild(optionLabel); // Add the styled option label to the grid
                         });
                     } else {
                          console.error(`Options list for q${index} is not an array:`, q.options);
                     }
                     correctionItem.appendChild(optionsGrid); // Append the styled options grid to the correction item
                }


            } else if (q.type === 'codeWrite' || q.type === 'textInput') {
                 // Handle correction display for code and text input types
                 let userAnswerDisplay = '<div class="text-muted-foreground p-4 border rounded-md">Pas de réponse soumise.</div>'; // Default display for no answer
                 // If user answered and the answer is a string
                 if (!isGenericView && isAnswered && typeof userAnswer === 'string') {
                     // Escape HTML for display
                     const escapedUserAnswer = userAnswer.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                     if (q.type === 'codeWrite') {
                          userAnswerDisplay = `<pre class="user-code">${escapedUserAnswer}</pre>`; // Code uses <pre>
                     } else { // textInput uses a simple div
                          userAnswerDisplay = `<div class="user-code text-muted-foreground p-4 border rounded-md whitespace-pre-wrap">${escapedUserAnswer}</div>`;
                     }
                 }

                 let correctAnswerDisplay = '<div class="text-muted-foreground p-4 border rounded-md">Correction manquante.</div>'; // Default for no correct answer
                 // Get correct answer for display (code or text)
                 const correctContent = q.type === 'codeWrite' ? q.correctCode : q.correctAnswer;
                 if (correctContent && typeof correctContent === 'string') {
                      const escapedCorrectContent = correctContent.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                      if (q.type === 'codeWrite') {
                           correctAnswerDisplay = `<pre class="correct-code">${escapedCorrectContent}</pre>`; // Code uses <pre>
                      } else { // textInput uses a simple div
                           correctAnswerDisplay = `<div class="correct-answer text-muted-foreground p-4 border rounded-md whitespace-pre-wrap">${escapedCorrectContent}</div>`;
                      }
                 }


                 correctionContent += `
                     <div class="text-sm mt-1 ${q.type}-correction">
                         <div class="font-semibold mb-1">Votre réponse :</div>
                          ${userAnswerDisplay} {/* Insert the user's answer display */}

                         <div class="font-semibold mt-3 mb-1">Correction :</div>
                         ${correctAnswerDisplay} {/* Insert the correct answer display */}

                         <div class="manual-grade-note"><i class="fas fa-exclamation-circle"></i> Cette question nécessite une correction manuelle pour l'attribution des points.</div>
                     </div>
                 `;
            } else if (q.type === 'deroulement') {
                 // Handle correction display for deroulement tables
                 let userAnswerTableDisplay = '<div class="text-muted-foreground">Pas de déroulement soumis.</div>'; // Default for no answer
                 // If user answered and the answer is a non-empty object
                 if (!isGenericView && isAnswered && typeof userAnswer === 'object' && userAnswer !== null && Object.keys(userAnswer).length > 0) {
                      // Check if user answer has the expected row structure before trying to map
                      // Build the HTML for the user's submitted table
                      const userTableRows = q.traceSteps.map((step, rowIndex) => {
                           if (!step || !step.Instruction) return ''; // Skip invalid step definition
                           // Map through the data columns (headers excluding Instruction)
                           const userCells = q.tableHeaders.slice(1).map((header, colIndex) => {
                                // Safely access user data: userAnswer[rowIndex][colIndex]
                                const cellValue = userAnswer[rowIndex]?.[colIndex] !== undefined ? userAnswer[rowIndex][colIndex] : ''; // Get cell value, default to empty string
                                // Escape HTML for display
                                const escapedCellValue = String(cellValue).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                                return `<td><input type="text" value="${escapedCellValue}" disabled></td>`; // Input disabled in correction
                           }).join(''); // Join cell HTML

                           return `<tr><td>${step.Instruction}</td>${userCells}</tr>`; // Instruction cell + data cells
                      }).join(''); // Join row HTML

                      userAnswerTableDisplay = `
                          <div class="table-container overflow-x-auto">
                             <table class="deroulement-table user-table">
                                 <thead><tr>${q.tableHeaders.map(header => `<th>${header}</th>`).join('')}</tr></thead> {/* Use defined headers */}
                                 <tbody>${userTableRows}</tbody> {/* Insert generated rows */}
                             </table>
                         </div>
                      `;
                 }

                 let correctTableDisplay = '<div class="text-muted-foreground">Correction manquante.</div>'; // Default for no correct answer
                 // Check if correctTraceData exists and is an array
                 if (Array.isArray(q.correctTraceData)) {
                     // Build the HTML for the correct table
                     const correctTableRows = q.correctTraceData.map((rowData, rowIndex) => {
                           if (!Array.isArray(rowData) || rowData.length === 0) return ''; // Skip if row data is invalid
                           // Map through the data in the rowData array
                           const correctCells = rowData.map((cellData, colIndex) => {
                                // Escape HTML for display
                                const escapedCellData = String(cellData !== undefined ? cellData : '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                                // The first cell is the instruction, the rest are data
                                return `<td><input type="text" value="${escapedCellData}" disabled></td>`; // Input disabled in correction
                           }).join(''); // Join cell HTML

                           return `<tr>${correctCells}</tr>`; // A row is the joined cells
                     }).join(''); // Join row HTML

                     correctTableDisplay = `
                         <div class="table-container overflow-x-auto">
                             <table class="deroulement-table correct-table">
                                 <thead>
                                     <tr>${q.tableHeaders.map(header => `<th>${header}</th>`).join('')}</tr> {/* Use defined headers */}
                                 </thead>
                                 <tbody>${correctTableRows}</tbody> {/* Insert generated rows */}
                             </table>
                         </div>
                     `;
                 } else {
                     console.error(`Correct trace data for q${index} is not an array:`, q.correctTraceData);
                 }


                 correctionContent += `
                     <div class="text-sm mt-1 deroulement-correction">
                          ${q.inputDescription ? `<p class="text-sm text-muted-foreground mb-2">Valeurs d'entrée : ${q.inputDescription}</p>` : ''}
                           ${q.algorithmCode ? `
                             <div class="font-semibold mt-2 mb-1">Extrait d'algorithme :</div>
                             <pre class="bg-gray-100 dark:bg-gray-800 p-4 rounded-md mb-4 overflow-x-auto text-sm">${q.algorithmCode.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</pre>` : ''}

                         <div class="font-semibold mb-1">Votre déroulement :</div>
                          ${userAnswerTableDisplay} {/* Insert user table display */}

                         <div class="font-semibold mt-3 mb-1">Correction :</div>
                         ${correctTableDisplay} {/* Insert correct table display */}

                         <div class="manual-grade-note"><i class="fas fa-exclamation-circle"></i> Cette question nécessite une correction manuelle pour l'attribution des points.</div>
                     </div>
                 `;
            }

            correctionItem.innerHTML = correctionContent; // Set the generated HTML as the content
            correctionListElement.appendChild(correctionItem); // Add the correction item to the list
        });
    }


    // --- Theme Toggle ---
    const themeToggle = document.getElementById('themeToggle');
    const body = document.body;

    // Event listener to toggle dark mode
    themeToggle.addEventListener('click', () => {
        body.classList.toggle('dark'); // Toggle the 'dark' class on the body
        const icon = themeToggle.querySelector('i'); // Find the icon inside the button
        icon.classList.toggle('fa-moon'); // Toggle the moon icon
        icon.classList.toggle('fa-sun'); // Toggle the sun icon
        // Save the user's preference to local storage
        localStorage.setItem('theme', body.classList.contains('dark') ? 'dark' : 'light');
    });

    // Loads saved theme preference from local storage on page load
    function loadTheme() {
        // Check local storage for a saved theme preference
        if (localStorage.getItem('theme') === 'dark') {
            body.classList.add('dark'); // Add the 'dark' class if preference is dark
            // Update the icon to the sun icon
            themeToggle.querySelector('i').classList.replace('fa-moon', 'fa-sun');
        }
        // If no preference or it's 'light', the default light theme is used (no 'dark' class)
    }


    // --- Initialization on Page Load ---
    // This async function runs when the page finishes loading.
    window.addEventListener('load', async () => {
        loadTheme(); // Apply the user's saved theme preference

        // Ensure the registered counter document exists in Firebase (creates it if not)
        await initializeRegisteredCounter();
         // Start listening for real-time updates to the registered counter.
         // This listener is active whenever the login or results sections are visible.
         startRegisteredCounterListener();

        // Check for existing user and session data in local storage
        const savedUser = localStorage.getItem(localStorageUserKey); // Get user data string
        // const savedAnswers = localStorage.getItem(localStorageAnswersKey); // Not directly used here for logic branches
        const savedStartTimeStr = localStorage.getItem(localStorageStartTimeKey); // Get session start time string
        const now = getClientTime().getTime(); // Get current time in milliseconds


        if (savedUser) { // If user data exists in local storage (means user previously logged in)
            const userData = JSON.parse(savedUser); // Parse the user data string into an object

            // Check Firebase if a submission already exists for this user's pseudo.
            const existingSubmission = await checkExistingSubmission(userData.pseudo);

            if (existingSubmission) {
                // Scenario 1: User has already submitted the exam.
                console.log("Existing submission found in DB for user. Showing results.");
                // Clear any potentially lingering local data from previous incomplete sessions for this specific exam.
                localStorage.removeItem(localStorageUserKey); // Log them out locally after a completed submission
                localStorage.removeItem(localStorageAnswersKey);
                localStorage.removeItem(localStorageStartTimeKey);
                // Transition to the results page for this user (will fetch their existing result from DB using pseudo)
                showResults({ pseudo: userData.pseudo }); // Pass only pseudo needed to fetch result
            } else if (savedStartTimeStr) {
                // Scenario 2: User logged in previously, did NOT submit, AND has a saved session start time.
                // This means there was an active session that might be resumable.
                const startTime = parseInt(savedStartTimeStr); // Parse the saved start time string
                const timeElapsed = now - startTime; // Calculate how much time has passed since the session started

                if (timeElapsed >= SESSION_DURATION_MS) {
                    // If the total session duration has passed since the start time: Session expired.
                    console.log("Local session expired. Showing results and prompting re-login.");
                    // Clear local data as the session is over and was not submitted in time.
                    localStorage.removeItem(localStorageUserKey); // Log them out locally
                    localStorage.removeItem(localStorageAnswersKey);
                    localStorage.removeItem(localStorageStartTimeKey);
                    alert("Votre session d'examen précédente a expiré. Vous devez vous reconnecter pour commencer une nouvelle tentative.");
                     // Show generic results + leaderboard. User must log in again to start a new attempt.
                    showLogin(); // showLogin calls startRegisteredCounterListener
                } else {
                    // If the session duration has NOT passed: Session is still active, resume the exam.
                    console.log("Resuming active local session.");
                     // User data and saved answers/start time are in local storage. Start the exam UI.
                    startExam(userData); // startExam calls stopRegisteredCounterListener
                }
            } else {
                 // Scenario 3: User logged in previously (user key exists) but NO savedStartTimeStr OR savedAnswers.
                 // This is an inconsistent state. It could happen if local storage was manually partially cleared,
                 // or if there was an error setting the start time initially, or user logged in after a previous session timed out and local data was cleared.
                 // Since checkExistingSubmission found NO submission for this pseudo, and no active session data (startTime) exists locally,
                 // we treat this as a valid attempt for this pseudo. A new session will be started from scratch.
                 console.log("Logged in without saved session data. Starting a new attempt session from clean state.");
                 const startTime = getClientTime().getTime(); // Set a NEW start time to begin a fresh 1h30 session
                 localStorage.setItem(localStorageStartTimeKey, startTime.toString()); // Save this new start time
                 // Ensure no old partial answers are loaded - explicitly clear the answers key just in case.
                 localStorage.removeItem(localStorageAnswersKey);
                 startExam(userData); // Start the exam UI. startExam calls stopRegisteredCounterListener.
            }
        } else {
            // Scenario 4: User data does NOT exist in local storage. First time or user previously logged out correctly.
            console.log("User data not found in localStorage. Showing login page.");
            // Clear any potentially orphaned local data just in case (shouldn't exist if logic is correct)
            localStorage.removeItem(localStorageUserKey);
            localStorage.removeItem(localStorageAnswersKey);
            localStorage.removeItem(localStorageStartTimeKey);
            showLogin(); // Transition to the login page. showLogin calls startRegisteredCounterListener.
        }
    });

    // --- Cleanup on Page Unload ---
    // This event fires when the user is about to leave the page (closing tab, navigating away, reloading).
    window.addEventListener('beforeunload', () => {
        stopExamTimer(); // Ensure the exam timer interval is cleared to prevent it from running in the background
        // We do NOT stop the registered counter listener here because it's managed by showLogin/startExam and might be needed on the next view (login/results).

        // If the user is currently in the exam state when leaving the page, attempt to save their current answers
        // This helps them resume if they accidentally close the tab or reload.
        if (!examSection.classList.contains('hidden')) {
             saveAnswers(); // This saves the current state of form answers and the session start time to local storage.
             console.log("Saving exam progress to localStorage before unload.");
        }
        // If the user is not in the exam state (e.g., on login or results page), local data is already cleared on logout or handled by the load logic.
    });

</script>
</body>
</html>