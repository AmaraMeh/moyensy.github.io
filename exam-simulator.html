<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Simulateur d'Examen - Méthodologie de la Présentation</title>
    <meta name="description" content="Simulateur d'examen pour la révision des étudiants en Méthodologie de la Présentation">
    <meta name="author" content="Amara Mehdi">
    <link rel="icon" type="image/png" href="assets/img/icon.png">
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --background: 0 0% 100%;
            --foreground: 222.2 84% 4.9%;
            --card: 0 0% 100%;
            --card-foreground: 222.2 84% 4.9%;
            --primary: 221.2 83.2% 53.3%;
            --primary-foreground: 210 40% 98%;
            --secondary: 210 40% 96.1%;
            --secondary-foreground: 222.2 47.4% 11.2%;
            --muted: 210 40% 96.1%;
            --muted-foreground: 215.4 16.3% 46.9%;
            --accent: 210 40% 96.1%;
            --accent-foreground: 222.2 47.4% 11.2%;
            --border: 214.3 31.8% 91.4%;
            --input: 214.3 31.8% 91.4%;
            --ring: 221.2 83.2% 53.3%;
            --radius: 0.5rem;

            /* Custom colors for correction */
            --correct-color: 120 60% 30%; /* Green */
            --incorrect-color: 0 80% 40%; /* Red */
        }

        .dark {
            --background: 222.2 84% 4.9%;
            --foreground: 210 40% 98%;
            --card: 222.2 84% 4.9%;
            --card-foreground: 210 40% 98%;
            --primary: 217.2 91.2% 59.8%;
            --primary-foreground: 222.2 47.4% 11.2%;
            --secondary: 217.2 32.6% 17.5%;
            --secondary-foreground: 210 40% 98%;
            --muted: 217.2 32.6% 17.5%;
            --muted-foreground: 215 20.2% 65.1%;
            --accent: 217.2 32.6% 17.5%;
            --accent-foreground: 210 40% 98%;
            --border: 217.2 32.6% 17.5%;
            --input: 217.2 32.6% 17.5%;
            --ring: 224.3 76.3% 48%;

             /* Custom colors for correction in dark mode */
            --correct-color: 145 63% 49%; /* Lighter Green */
            --incorrect-color: 350 80% 60%; /* Lighter Red */
        }

        body {
            font-family: 'Poppins', sans-serif;
            background: hsl(var(--background));
            color: hsl(var(--foreground));
            min-height: 100vh;
            -webkit-tap-highlight-color: transparent;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        .exam-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 1rem; /* Adjusted padding for better mobile fit */
        }

        .exam-card {
            background: hsl(var(--card));
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            padding: 1.5rem; /* Adjusted padding */
            margin-bottom: 1.5rem; /* Adjusted margin */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        .timer {
            font-size: 1.25rem; /* Slightly smaller on mobile */
            font-weight: bold;
            color: hsl(var(--primary));
            text-align: center;
            margin: 1rem 0;
        }
         @media (min-width: 640px) { /* Apply larger size on small screens and up */
             .timer {
                 font-size: 1.5rem;
             }
         }


        .question-container {
            margin: 1.5rem 0; /* Adjusted margin */
        }

        .option {
            display: flex;
            align-items: center;
            width: 100%;
            padding: 0.75rem; /* Adjusted padding */
            margin: 0.4rem 0; /* Adjusted margin */
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            background: hsl(var(--card));
            cursor: pointer;
            transition: all 0.3s ease;
            gap: 0.6rem; /* Adjusted gap */
        }

        .option:hover {
            background: hsl(var(--accent));
            border-color: hsl(var(--primary));
        }

        .option input[type="radio"],
        .option input[type="checkbox"] {
            margin-right: 0;
            width: 1.1rem; /* Slightly smaller on mobile */
            height: 1.1rem; /* Slightly smaller on mobile */
            flex-shrink: 0;
        }
         @media (min-width: 640px) {
             .option input[type="radio"],
             .option input[type="checkbox"] {
                  width: 1.2rem;
                  height: 1.2rem;
             }
         }


         /* Style for selected options */
        .option input[type="radio"]:checked + span,
        .option input[type="checkbox"]:checked + span {
             color: hsl(var(--primary-foreground));
        }

        .option input[type="radio"]:checked,
        .option input[type="checkbox"]:checked {
             accent-color: hsl(var(--primary));
        }

         /* Custom class for selected options background */
        .option.selected-option {
            background: hsl(var(--primary));
            color: hsl(var(--primary-foreground));
            border-color: hsl(var(--primary));
        }
        .option.selected-option input[type="radio"],
        .option.selected-option input[type="checkbox"] {
             accent-color: hsl(var(--primary-foreground));
        }


        .theme-toggle, .logout-button {
            position: fixed;
            bottom: 1rem;
            padding: 0.75rem;
            border-radius: 50%;
            background: hsl(var(--primary));
            color: hsl(var(--primary-foreground));
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 50; /* Ensure they are on top */
            border: none; /* Ensure no default button border */
        }
         .theme-toggle {
             right: 1rem;
         }
         .logout-button {
             left: 1rem;
             background: hsl(var(--secondary)); /* Use secondary color for distinction */
             color: hsl(var(--secondary-foreground));
         }
          .logout-button:hover:not(:disabled) {
              background: hsl(var(--secondary-foreground));
              color: hsl(var(--secondary));
          }


        .theme-toggle:hover:not(:disabled), .logout-button:hover:not(:disabled) {
            transform: scale(1.1);
        }
         .theme-toggle:disabled, .logout-button:disabled {
             cursor: not-allowed;
             opacity: 0.8;
         }


        .login-form {
            max-width: 400px;
            margin: 1.5rem auto; /* Adjusted margin */
            padding: 1.5rem; /* Adjusted padding */
            background: hsl(var(--card));
            border-radius: var(--radius);
            box-shadow: 0 44px 6px -1px rgba(0, 0, 0, 0.1);
            text-align: center;
        }

        .form-input {
            width: 100%;
            padding: 0.75rem;
            margin: 0.5rem 0;
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            background: hsl(var(--input));
            color: hsl(var(--foreground));
        }

        .btn {
            display: inline-block;
            padding: 0.75rem 1.5rem;
            background: hsl(var(--primary));
            color: hsl(var(--primary-foreground));
            border-radius: var(--radius);
            cursor: pointer;
            transition: all 0.3s ease;
            border: none;
            font-weight: 500;
            text-align: center;
            width: auto; /* Default width */
        }
         .btn.w-full { /* Use w-full class explicitly for full width */
             width: 100%;
         }


        .btn:hover:not(:disabled) { /* Apply hover effect only if not disabled */
            opacity: 0.9;
            transform: translateY(-1px);
        }

        .btn:disabled {
            background-color: hsl(var(--muted));
            color: hsl(var(--muted-foreground));
            cursor: not-allowed;
            transform: none;
            opacity: 0.8;
        }


        .leaderboard {
            margin-top: 1.5rem; /* Adjusted margin */
        }

        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem; /* Adjusted padding */
            border-bottom: 1px solid hsl(var(--border));
        }

        .leaderboard-item:last-child {
            border-bottom: none;
        }

        .stats-card {
            background: hsl(var(--card));
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            padding: 1rem;
            margin: 1rem 0;
            text-align: center;
        }

        .stats-number {
            font-size: 1.75rem; /* Slightly smaller */
            font-weight: bold;
            color: hsl(var(--primary));
        }
         @media (min-width: 640px) {
              .stats-number {
                 font-size: 2rem;
              }
         }


        .question-number {
            font-weight: bold;
            color: hsl(var(--primary));
            margin-bottom: 0.5rem;
        }

        .question-text {
            margin-bottom: 0.75rem; /* Adjusted margin */
        }

        .options-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); /* Adjusted min width for mobile */
            gap: 0.75rem; /* Adjusted gap */
            margin: 1rem 0;
        }

        .checkbox-option {
             /* This class was used on the label, now the label *is* the .option */
            display: flex; /* Ensure flexibility */
            align-items: center; /* Vertical alignment */
            gap: 0.5rem; /* Space between checkbox and text */
        }


        .progress-bar {
            width: 100%;
            height: 0.5rem;
            background: hsl(var(--muted));
            border-radius: var(--radius);
            overflow: hidden;
            margin: 1rem 0;
        }

        .progress-fill {
            height: 100%;
            background: hsl(var(--primary));
            transition: width 0.3s ease;
        }


        .rules-container {
            background: hsl(var(--card));
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            padding: 1.5rem; /* Adjusted padding */
            margin: 1.5rem 0; /* Adjusted margin */
        }

        .rules-title {
            font-size: 1.25rem; /* Adjusted size */
            font-weight: bold;
            margin-bottom: 1rem;
            color: hsl(var(--primary));
        }
         @media (min-width: 640px) {
             .rules-title {
                 font-size: 1.5rem;
             }
         }


        .rules-list {
            list-style-type: disc;
            padding-left: 1.25rem; /* Adjusted padding */
            margin: 1rem 0;
            font-size: 0.95rem; /* Slightly smaller text */
        }

        .rules-list li {
            margin: 0.4rem 0; /* Adjusted margin */
        }

        .correction-item {
             border-bottom: 1px solid hsl(var(--border));
             padding: 1rem 0;
        }
         .correction-item:last-child {
             border-bottom: none;
         }
         .correction-item .question-text {
             margin-bottom: 0.5rem;
             font-weight: 500;
         }
         .correction-item .correct-answer {
             color: hsl(var(--correct-color));
             font-weight: bold;
             font-size: 0.9rem;
             margin-top: 0.5rem;
         }
         .correction-item .user-answer {
             color: hsl(var(--incorrect-color));
             font-weight: bold;
             font-size: 0.9rem;
             margin-top: 0.2rem;
         }
         .correction-item .user-answer.correct {
             color: hsl(var(--correct-color));
         }
         /* Style for generic correction (when no user answer is shown) */
         .correction-item .correct-answer.generic {
             display: block; /* Ensure it takes its own line below the question */
             margin-top: 0.5rem;
         }
    </style>
</head>
<body>
    <div class="exam-container">
         <!-- Logout Button (Fixed position) -->
         <button id="logoutBtn" class="logout-button hidden" title="Déconnexion">
            <i class="fas fa-sign-out-alt"></i>
         </button>

        <!-- Login Section -->
        <div id="loginSection" class="login-form">
            <h2 class="text-2xl font-bold mb-4">Simulateur d'Examen</h2>
            <p class="text-lg mb-4">Méthodologie de la Présentation</p>

            <div class="rules-container text-left">
                <div class="rules-title">Règlement de l'examen simulé</div>
                <ul class="rules-list">
                    <li>L'examen est disponible **24h/24, 7j/7**.</li>
                    <li>Une fois l'examen démarré, vous disposez de **1h30** pour le compléter.</li>
                    <li>**30 questions** au total (20 Vrai/Faux et 10 QCM)</li>
                    <li>Barème : **1 point par réponse correcte** (pour les QCM, toutes les bonnes options doivent être cochées et aucune mauvaise).</li>
                    <li>Votre score et la correction seront affichés **immédiatement après la soumission** de l'examen.</li>
                    <li>Vos réponses sont sauvegardées localement dans votre navigateur pendant la session active (1h30).</li>
                    <li>Vous ne pouvez soumettre l'examen **qu'une seule fois** par pseudo.</li>
                </ul>
            </div>

            <div class="stats-card">
                <div class="stats-number" id="registeredCount">0</div>
                <div>Participants enregistrés (total)</div>
            </div>

            <form id="loginForm">
                <input type="text" id="pseudo" class="form-input" placeholder="Pseudo" required>
                <input type="password" id="pin" class="form-input" placeholder="Code PIN (4 chiffres)" pattern="[0-9]{4}" maxlength="4" required>
                <button type="submit" class="btn w-full mt-4">Commencer l'examen</button>
            </form>
        </div>

        <!-- Exam Section -->
        <div id="examSection" class="exam-card hidden">
            <div class="flex flex-col sm:flex-row justify-between items-center mb-4">
                <div class="timer mb-4 sm:mb-0" id="timer">01:30:00</div>
                <div class="stats-card w-full sm:w-auto">
                    <div class="stats-number" id="questionProgress">0/30</div>
                    <div>Questions répondues</div>
                </div>
            </div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill" style="width: 0%"></div>
            </div>
            <form id="examForm">
                 <div id="questionsContainer" class="question-container">
                     <!-- Questions will be dynamically added here -->
                 </div>
                <button type="submit" id="submitExam" class="btn w-full mt-4">Soumettre l'examen</button>
            </form>
        </div>

        <!-- Results Section -->
        <div id="resultsSection" class="exam-card hidden">
            <h2 class="text-2xl font-bold mb-4">Résultats et Classement</h2>

            <!-- User Result Summary (Shown if logged in and result found) -->
            <div id="userResultSummary" class="mb-6 hidden">
                <div class="stats-card">
                    <div class="stats-number" id="userScore">--/30</div>
                    <div>Votre score</div>
                </div>
                <!-- Correction is now always shown for logged-in user if result is found -->
            </div>

            <div class="stats-card">
                <div class="stats-number" id="submittedCount">0</div>
                <div>Participants ayant soumis</div>
            </div>

            <!-- Correction Section (Moved above leaderboard) -->
             <div id="correctionSection" class="correction-section mt-4 mb-8 hidden">
                 <h3 class="text-xl font-bold mb-4" id="correctionTitle">Votre Correction</h3>
                 <div id="correctionList">
                     <!-- Correction will be dynamically added here -->
                 </div>
             </div>

            <div class="leaderboard">
                <h3 class="text-xl font-bold mb-2">Classement</h3>
                <div id="leaderboardList">
                    <!-- Leaderboard will be dynamically added here -->
                     <div class="text-center p-4 text-muted-foreground">Chargement du classement...</div>
                </div>
            </div>
        </div>
    </div>

    <button id="themeToggle" class="theme-toggle" title="Changer de thème">
        <i class="fas fa-moon"></i>
    </button>


    <!-- Firebase SDK (Modular style using gstatic URLs) -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js";
        import { getFirestore, doc, getDoc, setDoc, collection, addDoc, getDocs, query, orderBy, limit, serverTimestamp, onSnapshot, where, increment } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js";

        // Your web app's Firebase configuration (replace with your actual config)
        const firebaseConfig = {
            apiKey: "AIzaSyB5XYqWKhHdiVDXJx4iOwtpxD8eUCPRfKU",
            authDomain: "universite-de-bejaia-547fc.firebaseapp.com",
            databaseURL: "https://universite-de-bejaia-547fc-default-rtdb.europe-west1.firebasedatabase.app", // Note: Realtime Database URL, but we are using Firestore
            projectId: "universite-de-bejaia-547fc",
            storageBucket: "universite-de-bejaia-547fc.firebasestorage.app",
            messagingSenderId: "517622731583",
            appId: "1:517622731583:web:25453d5e01226585bf798a",
            measurementId: "G-SQ0WWSCS7B" // Analytics ID
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        // Helper function to get current time (using local time for session start/end calculations)
        // Note: Firebase timestamp is used for submission time, ensuring consistency.
        function getClientTime() {
            return new Date();
        }

        // Exam Duration (1 hour 30 minutes)
        const SESSION_DURATION_MS = 90 * 60 * 1000;

        // UI Elements
        const loginSection = document.getElementById('loginSection');
        const examSection = document.getElementById('examSection');
        const resultsSection = document.getElementById('resultsSection');

        const examTimerElement = document.getElementById('timer');

        const loginForm = document.getElementById('loginForm');
        const pseudoInput = document.getElementById('pseudo');
        const pinInput = document.getElementById('pin');
        const registeredCountElement = document.getElementById('registeredCount');
        const submittedCountElement = document.getElementById('submittedCount');

        const questionsContainer = document.getElementById('questionsContainer');
        const questionProgressElement = document.getElementById('questionProgress');
        const progressFillElement = document.getElementById('progressFill');
        const submitExamButton = document.getElementById('submitExam');

        const userResultSummaryElement = document.getElementById('userResultSummary');
        const userScoreElement = document.getElementById('userScore');
        const leaderboardListElement = document.getElementById('leaderboardList');
        const correctionSectionElement = document.getElementById('correctionSection');
        const correctionListElement = document.getElementById('correctionList');
         const correctionTitleElement = document.getElementById('correctionTitle'); // Get title element
         const logoutBtn = document.getElementById('logoutBtn');


        // Questions data (Integrated from your list) - Same as before
        const questions = [
            { type: 'trueFalse', text: 'Faire un exposé oral implique de présenter les résultats d\'un travail de recherche devant un auditoire.', answer: true },
            { type: 'trueFalse', text: 'L\'un des buts de l\'exposé oral est de convaincre l\'auditoire.', answer: true },
            { type: 'trueFalse', text: 'Un exposé oral efficace ne nécessite pas d\'être visuel ou expressif.', answer: false },
            { type: 'trueFalse', text: 'Pour préparer un exposé oral, il est nécessaire de trouver une problématique et d\'y répondre de façon argumentée.', answer: true },
            { type: 'trueFalse', text: 'Lorsque l\'on utilise Internet pour un exposé, il est important de trier les sources et d\'analyser les documents pertinents.', answer: true },
            { type: 'trueFalse', text: 'Pour une présentation orale, le plan structuré doit idéalement comporter cinq parties ou plus.', answer: false },
            { type: 'trueFalse', text: 'Lors d\'une présentation orale, il est préférable d\'écrire l\'intégralité de son texte sur les supports (comme des notes) pour éviter d\'oublier des points.', answer: false },
            { type: 'trueFalse', text: 'L\'échelle de déformation du message décrit une perte progressive du message entre l\'émetteur et le récepteur.', answer: true },
            { type: 'trueFalse', text: 'Le "Code" dans le schéma de communication est la personne qui est à l\'origine du message.', answer: false },
            { type: 'trueFalse', text: 'Le corps et la voix sont des instruments de l\'expression orale.', answer: true },
            { type: 'trueFalse', text: 'La façon de s\'exprimer oralement ne change pas en fonction de l\'interlocuteur (ami, collègue, supérieur).', answer: false },
            { type: 'trueFalse', text: 'La respiration est importante car elle conditionne la bonne émission du son et favorise la détente.', answer: true },
            { type: 'trueFalse', text: 'L\'Intonation est le mouvement mélodique de la voix.', answer: true },
            { type: 'trueFalse', text: 'Un débit de parole uniforme est conseillé pour éviter de perturber l\'auditoire.', answer: false },
            { type: 'trueFalse', text: 'L\'Articulation est le fait de varier le ton de la voix.', answer: false },
            { type: 'trueFalse', text: 'Le trac est la peur ressentie avant d\'affronter un public.', answer: true },
            { type: 'trueFalse', text: 'Le trac ne se dissipe pas dans l\'action, il ne fait qu\'empirer.', answer: false },
            { type: 'trueFalse', text: 'La répétition d\'un mot ou d\'une expression est une technique inutile en expression orale.', answer: false },
            { type: 'trueFalse', text: 'Le silence pendant un exposé permet notamment de reprendre son souffle et de regarder l\'auditoire.', answer: true },
            { type: 'trueFalse', text: 'Le regard de l\'orateur peut transmettre des sentiments ou des volontés.', answer: true },
            { type: 'multiple', text: 'Selon le cours, quels sont les principaux facteurs du schéma de communication ?', options: ['Le Rythme', 'Le Récepteur', 'Le Support Visuel', 'Le Canal', 'Le Message'], answer: [1, 3, 4] }, // Indices des bonnes réponses
            { type: 'multiple', text: 'Parmi les éléments suivants, lesquels font partie des techniques d\'expression orale liées à la voix, telles que décrites dans le cours ?', options: ['Les Gestes', 'Le Débit', 'La Posture', 'La Modulation', 'L\'Articulation'], answer: [1, 3, 4] },
            { type: 'multiple', text: 'Le trac peut entraîner les manifestations physiques suivantes :', options: ['Jambes molles', 'Sentiment d\'oppression', 'Langue desséchée', 'Grande confiance en soi', 'Crampes'], answer: [0, 1, 2, 4] },
            { type: 'multiple', text: 'Selon le cours, la gestion du trac peut être améliorée par :', options: ['Une préparation insuffisante pour stimuler l\'adrénaline', 'La relaxation physique et mentale', 'Un entraînement régulier', 'L\'amélioration de la respiration', 'La consommation de boissons énergisantes'], answer: [1, 2, 3] },
            { type: 'multiple', text: 'Quelle(s) distance(s) de communication interpersonnelle est/sont décrite(s) dans le cours ?', options: ['La zone Intime', 'La zone Professionnelle', 'La zone Sociale', 'La zone Personnelle', 'La zone Publique'], answer: [0, 2, 3, 4] },
            { type: 'multiple', text: 'Selon le Chapitre 2, la réussite d\'une présentation orale dépend de :', options: ['La qualité de l\'oralité', 'La complexité des graphiques utilisés', 'La rigueur du support visuel', 'La pertinence du contenu'], answer: [0, 2, 3] },
            { type: 'multiple', text: 'Quelle est la structure temporelle recommandée pour les différentes parties d\'une présentation orale ?', options: ['L\'introduction représente 10% du temps.', 'Le corps représente la majeure partie du temps.', 'La conclusion doit être aussi longue que l\'introduction.', 'Le corps représente 80% du temps.'], answer: [0, 1, 3] },
            { type: 'multiple', text: 'Lors de la conception des diapositives, que recommande le cours concernant la typographie ?', options: ['Utiliser uniquement des polices fantaisie pour capter l\'attention.', 'Préférer des polices comme ARIAL ou UNIVERS.', 'La taille minimale des caractères doit être de 18 points.', 'La taille idéale des caractères est entre 26 et 28 points.'], answer: [1, 2, 3] },
            { type: 'multiple', text: 'Concernant le graphisme des diapositives, quels conseils sont donnés ?', options: ['Utiliser un fond différent pour chaque diapositive.', 'Préférer un fond uni et identique pour toutes les diapositives.', 'Utiliser des couleurs agressives comme le rouge vif pour les titres.', 'Éviter le souligné en écriture électronique.'], answer: [1, 3] },
            { type: 'multiple', text: 'Que faut-il éviter lors de la création du support visuel selon le cours ?', options: ['Les fautes d\'orthographe.', 'L\'écriture en majuscules.', 'L\'abus d\'animations complexes.', 'De mettre des mots-clés sur les diapositives.'], answer: [0, 1, 2] }
        ];

        // --- Firebase Counters ---
        const registeredCounterRef = doc(db, 'counters', 'methodologie_presentation_registered');
        const examResultsCollection = collection(db, 'examResults_methodologie');

        // Initialize counter if it doesn't exist
        const initializeRegisteredCounter = async () => {
            try {
                const counterDoc = await getDoc(registeredCounterRef);
                if (!counterDoc.exists()) {
                    await setDoc(registeredCounterRef, { count: 0 });
                }
            } catch (error) {
                console.error("Error initializing registered counter:", error);
            }
        };

        // Listen for real-time updates to the registered counter
        let unsubscribeRegisteredCounter = null;
        const startRegisteredCounterListener = () => {
             if (!unsubscribeRegisteredCounter) {
                unsubscribeRegisteredCounter = onSnapshot(registeredCounterRef, (doc) => {
                    if (doc.exists()) {
                        registeredCountElement.textContent = doc.data().count;
                    } else {
                         registeredCountElement.textContent = 'N/A';
                    }
                }, (error) => {
                     console.error("Error listening to registered counter:", error);
                     registeredCountElement.textContent = 'Erreur';
                });
             }
        };
        const stopRegisteredCounterListener = () => {
             if (unsubscribeRegisteredCounter) {
                 unsubscribeRegisteredCounter();
                 unsubscribeRegisteredCounter = null;
             }
        };

        // --- Timer Logic (Per Session) ---
        let examTimerInterval = null;
        let sessionStartTime = null; // Stored locally in localStorage

        function formatTime(ms) {
            if (ms < 0) ms = 0;
            const totalSeconds = Math.floor(ms / 1000);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        function startExamTimer() {
            // Clear any existing exam timer
            if (examTimerInterval) {
                 clearInterval(examTimerInterval);
            }

             // Load session start time from localStorage
             const savedStartTime = localStorage.getItem('examStartTime_methodologie');
             if (!savedStartTime) {
                 // This should ideally be set before calling this function, but as a fallback
                 console.error("Session start time not found. Starting new session.");
                 sessionStartTime = getClientTime().getTime();
                 localStorage.setItem('examStartTime_methodologie', sessionStartTime.toString());
             } else {
                 sessionStartTime = parseInt(savedStartTime);
             }

            const now = getClientTime().getTime();
            let remainingTimeMs = SESSION_DURATION_MS - (now - sessionStartTime);

            if (remainingTimeMs <= 0) {
                 // Time already up or expired
                 examTimerElement.textContent = "00:00:00";
                 // Automatically submit if time is up
                 // Use a small timeout to ensure the UI updates before submitting
                 setTimeout(submitExam, 50);
                 return;
            }

            examTimerElement.textContent = formatTime(remainingTimeMs);

            examTimerInterval = setInterval(() => {
                remainingTimeMs -= 1000; // Decrease by 1 second

                if (remainingTimeMs <= 0) {
                    clearInterval(examTimerInterval);
                    examTimerInterval = null;
                    examTimerElement.textContent = "00:00:00";
                    submitExam(); // Time's up, submit
                    alert("Votre temps est écoulé ! L'examen a été soumis automatiquement.");
                    return;
                }

                examTimerElement.textContent = formatTime(remainingTimeMs);
            }, 1000);
        }

        function stopExamTimer() {
             if (examTimerInterval) {
                 clearInterval(examTimerInterval);
                 examTimerInterval = null;
             }
        }

        // --- UI State Management ---
        function hideAllSections() {
            loginSection.classList.add('hidden');
            examSection.classList.add('hidden');
            resultsSection.classList.add('hidden');
            logoutBtn.classList.add('hidden');
        }

        function showLogin() {
             hideAllSections();
             loginSection.classList.remove('hidden');
             logoutBtn.classList.add('hidden'); // Hide logout button on login page
             startRegisteredCounterListener(); // Listen on login page
        }

        function startExam(userData) {
            hideAllSections();
            examSection.classList.remove('hidden');
            logoutBtn.classList.remove('hidden'); // Show logout during exam
            displayQuestions(); // Render questions
            loadSavedAnswers(); // Load answers from local storage (and sessionStartTime)
            updateProgress(); // Update progress based on loaded answers
            startExamTimer(); // Start the countdown timer based on session start time
            stopRegisteredCounterListener(); // Stop listener during exam
        }

        async function showResults(userData = null) {
            hideAllSections();
            resultsSection.classList.remove('hidden');
            logoutBtn.classList.remove('hidden'); // Show logout on results page
            startRegisteredCounterListener(); // Listen on results page

            // Clear previous content
            userResultSummaryElement.classList.add('hidden');
            correctionListElement.innerHTML = '';
            correctionSectionElement.classList.add('hidden');
            leaderboardListElement.innerHTML = '<div class="text-center p-4 text-muted-foreground">Chargement du classement...</div>';


            let userResult = null;
            if (userData) {
                try {
                    // Fetch the submitted result for the logged-in user
                    const userResultQuery = query(examResultsCollection, where('pseudo', '==', userData.pseudo), limit(1));
                    const userResultSnapshot = await getDocs(userResultQuery);

                    if (!userResultSnapshot.empty) {
                        userResult = userResultSnapshot.docs[0].data();
                        userResultSummaryElement.innerHTML = `
                            <div class="stats-card">
                                <div class="stats-number">${userResult.score}/${questions.length}</div>
                                <div>Votre score</div>
                            </div>
                        `;
                        userResultSummaryElement.classList.remove('hidden');
                         // Display personalized correction if logged in and result found
                         displayCorrection(userResult.userAnswers, false);
                    } else {
                         // Logged in but no result found (e.g., session timed out before submitting)
                         userResultSummaryElement.innerHTML = `<div class="stats-card"><p>Aucun résultat soumis trouvé pour ${userData.pseudo}.</p></div>`;
                         userResultSummaryElement.classList.remove('hidden');
                         // Display generic correction
                         displayCorrection(null, true);
                    }
                } catch (error) {
                    console.error("Error fetching user result:", error);
                    userResultSummaryElement.innerHTML = `<div class="stats-card"><p>Erreur lors du chargement de vos résultats.</p></div>`;
                    userResultSummaryElement.classList.remove('hidden');
                     // Display generic correction on error
                     displayCorrection(null, true);
                }
            } else {
                // Not logged in, just show generic correction
                displayCorrection(null, true);
            }

            // Update general stats (submitted count) and leaderboard for everyone
            await updateSubmittedCount();
            await updateLeaderboard();
        }

         async function checkExistingSubmission(pseudo) {
             try {
                 const existingResultQuery = query(examResultsCollection, where('pseudo', '==', pseudo), limit(1));
                 const existingResultSnapshot = await getDocs(existingResultQuery);
                 return !existingResultSnapshot.empty;
             } catch (error) {
                 console.error("Error checking for existing submission:", error);
                 // In case of error, err on the side of caution and allow starting, but warn
                 alert("Erreur de connexion lors de la vérification de votre pseudo. Veuillez réessayer.");
                 return false; // Assume no existing submission if check fails
             }
         }


        // --- Login Functionality ---
        loginForm.addEventListener('submit', async (e) => {
            e.preventDefault();

            const pseudo = pseudoInput.value.trim();
            const pin = pinInput.value;

            if (!pseudo) {
                 alert("Veuillez entrer un Pseudo.");
                 return;
            }
             if (!/^[0-9]{4}$/.test(pin)) {
                 alert("Le Code PIN doit être composé de 4 chiffres.");
                 return;
             }

            // Check if pseudo already has a *submitted* result to prevent duplicates
             const existingSubmission = await checkExistingSubmission(pseudo);
             if (existingSubmission) {
                 alert(`Un résultat existe déjà pour le pseudo "${pseudo}". Vous ne pouvez soumettre l'examen qu'une seule fois.`);
                 // Redirect to results page where they can see their score/correction
                 const userData = { pseudo, pin }; // Keep user data for results page
                 localStorage.setItem('examUser', JSON.stringify(userData));
                 showResults(userData);
                 return; // Prevent starting the exam
             }


            // If no existing submission, store user data and start the exam session
            const userData = { pseudo, pin };
            localStorage.setItem('examUser', JSON.stringify(userData));
            // Also set the session start time now
            const startTime = getClientTime().getTime();
            localStorage.setItem('examStartTime_methodologie', startTime.toString());


            // Increment participant counter (only on first successful login without prior submission)
             try {
                await setDoc(registeredCounterRef, { count: increment(1) }, { merge: true });
             } catch (error) {
                 console.error("Error incrementing registered counter:", error);
             }

            startExam(userData);
        });

         // --- Logout Functionality ---
         logoutBtn.addEventListener('click', handleLogout);

         function handleLogout() {
             const inExam = !examSection.classList.contains('hidden');

             if (inExam) {
                 if (!confirm("Vous êtes en train de passer l'examen. Si vous vous déconnectez, votre progression locale sera perdue et votre examen ne sera pas soumis. Voulez-vous continuer la déconnexion ?")) {
                     return; // User cancelled logout
                 }
                 // If user confirms during exam, answers are saved locally by the input change listener
             } else {
                  // If not in exam, just ask for confirmation
                 if (!confirm("Voulez-vous vraiment vous déconnecter ?")) {
                     return; // User cancelled logout
                 }
             }

             // Clear all local storage related to the exam session/user
             localStorage.removeItem('examUser');
             localStorage.removeItem('examAnswers');
             localStorage.removeItem('examStartTime_methodologie');

             stopExamTimer(); // Stop the timer
             showLogin(); // Go back to the login screen
             alert("Vous avez été déconnecté.");
         }


        // --- Exam Logic ---
        function displayQuestions() {
            questionsContainer.innerHTML = ''; // Clear existing questions
            questions.forEach((question, index) => {
                const questionElement = document.createElement('div');
                questionElement.className = 'mb-8';
                questionElement.setAttribute('data-question-index', index); // Add index attribute for easier lookup

                questionElement.innerHTML = `
                    <div class="question-number">Question ${index + 1}</div>
                    <div class="question-text">${question.text}</div>
                    ${question.type === 'trueFalse' ? `
                        <div class="options-grid">
                            <label class="option" data-q="${index}" data-value="true">
                                <input type="radio" name="q${index}" value="true" required>
                                <span>Vrai</span>
                            </label>
                            <label class="option" data-q="${index}" data-value="false">
                                <input type="radio" name="q${index}" value="false" required>
                                <span>Faux</span>
                            </label>
                        </div>
                    ` : `
                        <div class="options-grid">
                            ${question.options.map((option, optIndex) => `
                                <label class="option checkbox-option" data-q="${index}" data-value="${optIndex}">
                                    <input type="checkbox" name="q${index}" value="${optIndex}">
                                    <span>${option}</span>
                                </label>
                            `).join('')}
                        </div>
                    `}
                `;
                questionsContainer.appendChild(questionElement);
            });

             // Add event listener for answer selection to save and update progress
            questionsContainer.addEventListener('change', handleAnswerChange);
        }

        function handleAnswerChange(e) {
            const input = e.target;
            if (input.matches('input[type="radio"], input[type="checkbox"]')) {
                 saveAnswers(); // Save all answers on any change
                 updateProgress(); // Update progress bar
                 updateOptionClasses(); // Update visual selected class
            }
        }

         function updateOptionClasses() {
             // Loop through all questions displayed
             questionsContainer.querySelectorAll('.mb-8').forEach(questionElement => {
                 const qIndex = questionElement.getAttribute('data-question-index');
                 const options = questionElement.querySelectorAll('.option');
                 options.forEach(label => {
                     const input = label.querySelector('input');
                     if (input && input.checked) {
                         label.classList.add('selected-option');
                     } else {
                         label.classList.remove('selected-option');
                     }
                 });
             });
         }


        function saveAnswers() {
            const answers = {};
            questionsContainer.querySelectorAll('.mb-8').forEach(questionElement => {
                 const index = parseInt(questionElement.getAttribute('data-question-index'));
                 const selectedInputs = questionElement.querySelectorAll(`input[name="q${index}"]:checked`);

                if (selectedInputs.length > 0) {
                    if (questions[index].type === 'trueFalse') {
                        answers[index] = selectedInputs[0].value === 'true';
                    } else { // multiple choice
                        answers[index] = Array.from(selectedInputs).map(input => parseInt(input.value));
                    }
                 }
                 // If selectedInputs.length is 0, the key for that question is not added, meaning unanswered
            });

            // Also save the current session start time
            const currentSessionStartTime = localStorage.getItem('examStartTime_methodologie');

            localStorage.setItem('examAnswers', JSON.stringify(answers));
             // Ensure start time is saved alongside answers
             if (currentSessionStartTime) {
                 localStorage.setItem('examStartTime_methodologie', currentSessionStartTime);
             }
        }

        function loadSavedAnswers() {
            const savedAnswers = localStorage.getItem('examAnswers');
            if (savedAnswers) {
                try {
                    const answers = JSON.parse(savedAnswers);
                    questionsContainer.querySelectorAll('.mb-8').forEach(questionElement => {
                        const qIndex = parseInt(questionElement.getAttribute('data-question-index'));
                        const userAnswer = answers[qIndex];

                        if (userAnswer !== undefined) {
                            if (questions[qIndex].type === 'trueFalse') {
                                const input = questionElement.querySelector(`input[name="q${qIndex}"][value="${userAnswer}"]`);
                                if (input) {
                                    input.checked = true;
                                }
                            } else { // multiple choice
                                if (Array.isArray(userAnswer)) {
                                    userAnswer.forEach(optIndex => {
                                        const input = questionElement.querySelector(`input[name="q${qIndex}"][value="${optIndex}"][type="checkbox"]`);
                                        if (input) {
                                            input.checked = true;
                                        }
                                    });
                                }
                            }
                        }
                    });
                     updateOptionClasses(); // Apply selected style after loading
                } catch (e) {
                    console.error("Failed to load saved answers from localStorage:", e);
                    // Clear potentially corrupted data and the related start time
                    localStorage.removeItem('examAnswers');
                    localStorage.removeItem('examStartTime_methodologie');
                    alert("Erreur: Impossible de charger vos réponses sauvegardées localement. Vous commencerez un nouvel examen.");
                    // If loading fails, treat as a fresh start for answers, but the timer logic handles session expiration.
                }
            }
        }


        function updateProgress() {
            let answeredCount = 0;
             questionsContainer.querySelectorAll('.mb-8').forEach(questionElement => {
                 const selectedInputs = questionElement.querySelectorAll('input:checked');
                 if (selectedInputs.length > 0) {
                     answeredCount++;
                 }
             });

            questionProgressElement.textContent = `${answeredCount}/${questions.length}`;
            progressFillElement.style.width = `${(answeredCount / questions.length) * 100}%`;
        }


        function calculateScore(userAnswersObject) {
            let score = 0;
            questions.forEach((question, index) => {
                const userAnswer = userAnswersObject ? userAnswersObject[index] : undefined;

                if (userAnswer === undefined) {
                    return; // Unanswered question gets 0 points
                }

                if (question.type === 'trueFalse') {
                    if (userAnswer === question.answer) {
                        score++;
                    }
                } else { // multiple choice
                    const correctAnswers = question.answer.slice().sort();
                    const submittedAnswers = Array.isArray(userAnswer) ? userAnswer.slice().sort() : [];

                     if (submittedAnswers.length === correctAnswers.length &&
                         submittedAnswers.every((val, i) => val === correctAnswers[i])) {
                        score++;
                    }
                }
            });
            return score;
        }

        // Submit Exam
        document.getElementById('examForm').addEventListener('submit', async (e) => {
             e.preventDefault();
             await submitExam();
        });


        async function submitExam() {
             // Disable submit button
             submitExamButton.disabled = true;
             submitExamButton.textContent = 'Soumission en cours...';

            // Get the user's answers from the current form state
            const userAnswers = {};
             questionsContainer.querySelectorAll('.mb-8').forEach(questionElement => {
                 const index = parseInt(questionElement.getAttribute('data-question-index'));
                 const selectedInputs = questionElement.querySelectorAll(`input[name="q${index}"]:checked`);
                 if (selectedInputs.length > 0) {
                    if (questions[index].type === 'trueFalse') {
                        userAnswers[index] = selectedInputs[0].value === 'true';
                    } else { // multiple choice
                        userAnswers[index] = Array.from(selectedInputs).map(input => parseInt(input.value));
                    }
                 }
             });

            const score = calculateScore(userAnswers);
            const userData = JSON.parse(localStorage.getItem('examUser'));

             if (!userData || !userData.pseudo || !userData.pin) {
                 alert("Erreur de session : Veuillez vous reconnecter.");
                 showLogin();
                  submitExamButton.disabled = false; // Re-enable if login redirect fails for some reason
                  submitExamButton.textContent = 'Soumettre l\'examen';
                 return;
             }

            try {
                // Check for existing submission one last time before writing
                 const existingSubmission = await checkExistingSubmission(userData.pseudo);

                 if (existingSubmission) {
                     alert(`Un résultat existe déjà pour le pseudo "${userData.pseudo}". Votre examen précédent a déjà été enregistré.`);
                     // Redirect to results page
                     showResults(userData);
                 } else {
                     // Save results to Firebase
                     await addDoc(examResultsCollection, {
                         pseudo: userData.pseudo,
                         pin: userData.pin, // Optionally save PIN
                         score: score,
                         userAnswers: userAnswers, // Save user's answers for correction
                         timestamp: serverTimestamp() // Use server timestamp for ranking ties
                     });

                    alert(`Votre examen a été soumis avec succès ! Votre score est de ${score}/${questions.length}.`);

                    // Clear local storage for this exam's session after successful submission
                    localStorage.removeItem('examAnswers');
                    localStorage.removeItem('examStartTime_methodologie');
                    stopExamTimer(); // Stop the timer

                     // Update submitted count immediately
                    await updateSubmittedCount(); // Call async function

                    // Transition to results page
                    showResults(userData);
                 }

            } catch (error) {
                console.error("Erreur lors de la soumission de l'examen:", error);
                alert("Une erreur est survenue lors de la soumission de l'examen. Veuillez vérifier votre connexion. Si le problème persiste, notez votre score et contactez l'organisateur.");
                 submitExamButton.disabled = false; // Re-enable button on error
                 submitExamButton.textContent = 'Soumettre l\'examen';
                 // Don't clear local storage in case of Firebase error
            }
        }


        // --- Results Logic ---
        async function updateLeaderboard() {
            try {
                 // Order by score descending, then timestamp ascending (for ties)
                const snapshot = await getDocs(query(examResultsCollection, orderBy('score', 'desc'), orderBy('timestamp', 'asc')));
                leaderboardListElement.innerHTML = ''; // Clear current list

                if (snapshot.empty) {
                    leaderboardListElement.innerHTML = '<div class="text-center p-4 text-muted-foreground">Aucun résultat disponible pour le moment.</div>';
                } else {
                    snapshot.forEach((doc, index) => {
                        const data = doc.data();
                        const item = document.createElement('div');
                        item.className = 'leaderboard-item';
                        item.innerHTML = `
                            <span>${index + 1}. ${data.pseudo}</span>
                            <span>${data.score}/${questions.length}</span>
                        `;
                        leaderboardListElement.appendChild(item);
                    });
                }
            } catch (error) {
                 console.error("Error fetching leaderboard:", error);
                 leaderboardListElement.innerHTML = '<div class="text-center p-4 text-muted-foreground">Erreur lors du chargement du classement.</div>';
            }
        }

         async function updateSubmittedCount() {
             try {
                  const snapshot = await getDocs(examResultsCollection);
                  submittedCountElement.textContent = snapshot.size;
             } catch (error) {
                  console.error("Error fetching submitted count:", error);
                  submittedCountElement.textContent = 'N/A';
             }
         }


         function displayCorrection(userAnswers, isGenericView = false) {
             correctionListElement.innerHTML = ''; // Clear previous correction

             if (isGenericView) {
                 correctionTitleElement.textContent = 'Correction des Questions';
             } else {
                 correctionTitleElement.textContent = 'Votre Correction';
             }
             correctionSectionElement.classList.remove('hidden'); // Show the correction section


             questions.forEach((q, index) => {
                 const userAnswer = userAnswers ? userAnswers[index] : undefined;
                 const isAnswered = userAnswer !== undefined;

                 let userAnswerText = '';
                 let isCorrect = false; // Assume incorrect unless proven correct

                 if (!isGenericView && isAnswered) {
                     // Calculate score for this single question
                     const singleQuestionScore = calculateScore({[index]: userAnswer});
                     isCorrect = (singleQuestionScore === 1);

                     if (q.type === 'trueFalse') {
                         userAnswerText = userAnswer ? 'Vrai' : 'Faux';
                     } else if (Array.isArray(userAnswer)) {
                         const selectedOptionsText = userAnswer.sort().map(i => {
                             if (q.options && q.options[i] !== undefined) {
                                return q.options[i];
                             } else {
                                 return `Option Index ${i}`;
                             }
                         });
                         userAnswerText = selectedOptionsText.length > 0 ? selectedOptionsText.join(', ') : 'Aucune option sélectionnée';
                     } else {
                          userAnswerText = 'Format de réponse inattendu'; // Should not happen with correct saving
                     }
                 }

                 let correctAnswerText;
                 if (q.type === 'trueFalse') {
                     correctAnswerText = q.answer ? 'Vrai' : 'Faux';
                 } else {
                     const correctOptionsText = q.answer.sort().map(i => {
                         if (q.options && q.options[i] !== undefined) {
                                return q.options[i];
                            } else {
                                return `Option Index ${i}`;
                            }
                     });
                     correctAnswerText = correctOptionsText.join(', ');
                 }

                 const correctionItem = document.createElement('div');
                 correctionItem.className = 'correction-item';

                 let userAnswerLine = '';
                 if (!isGenericView) {
                     if (isAnswered) {
                         userAnswerLine = `<br><span class="user-answer ${isCorrect ? 'correct' : ''}">Votre réponse: ${userAnswerText}</span>`;
                     } else {
                         userAnswerLine = `<br><span class="user-answer">Vous n'avez pas répondu</span>`;
                     }
                 } else {
                      // In generic view, add a class to the correct answer span for styling consistency
                      correctAnswerText = `<span class="correct-answer generic">Correcte: ${correctAnswerText}</span>`;
                 }


                 correctionItem.innerHTML = `
                     <div class="font-bold">Question ${index + 1}</div>
                     <div class="question-text">${q.text}</div>
                     <div class="text-sm mt-1">
                          ${isGenericView ? correctAnswerText : `<span class="correct-answer">Correcte: ${correctAnswerText}</span>${userAnswerLine}`}
                     </div>
                 `;
                 correctionListElement.appendChild(correctionItem);
             });
         }


        // --- Theme Toggle ---
        const themeToggle = document.getElementById('themeToggle');
        const body = document.body;

        themeToggle.addEventListener('click', () => {
            body.classList.toggle('dark');
            const icon = themeToggle.querySelector('i');
            icon.classList.toggle('fa-moon');
            icon.classList.toggle('fa-sun');
            localStorage.setItem('theme', body.classList.contains('dark') ? 'dark' : 'light');
        });

        // Load saved theme on startup
        function loadTheme() {
             if (localStorage.getItem('theme') === 'dark') {
                 body.classList.add('dark');
                 themeToggle.querySelector('i').classList.replace('fa-moon', 'fa-sun');
             }
        }


        // --- Initialization on Page Load ---
        window.addEventListener('load', async () => {
            loadTheme(); // Apply saved theme
            await initializeRegisteredCounter(); // Ensure counter exists
            // Start listening to registered count immediately - it's shown on login/results

            const savedUser = localStorage.getItem('examUser');
            const savedStartTimeStr = localStorage.getItem('examStartTime_methodologie');
            const now = getClientTime().getTime();

            if (savedUser) {
                 const userData = JSON.parse(savedUser);

                 // Check if the user already submitted
                 const existingSubmission = await checkExistingSubmission(userData.pseudo);

                 if (existingSubmission) {
                     // User already submitted, go straight to results
                     localStorage.removeItem('examAnswers'); // Clear any lingering local answers
                     localStorage.removeItem('examStartTime_methodologie'); // Clear lingering start time
                     showResults(userData);
                 } else if (savedStartTimeStr) {
                     // User is logged in and has a saved session start time
                     const startTime = parseInt(savedStartTimeStr);
                     const timeElapsed = now - startTime;

                     if (timeElapsed >= SESSION_DURATION_MS) {
                         // Session expired, clear local data and show results
                         localStorage.removeItem('examAnswers');
                         localStorage.removeItem('examStartTime_methodologie');
                         alert("Votre session d'examen précédente a expiré.");
                          // Since they didn't submit in time, show generic results or a message
                          // For simplicity, show generic results+leaderboard
                         showResults(); // Show results without user specific data initially, maybe fetch their result later if it exists
                     } else {
                         // Session is still active, resume the exam
                         startExam(userData);
                     }
                 } else {
                     // Logged in, but no saved session start time or answers (e.g., cleared local data, or new login after timeout)
                      // Since existingSubmission check passed, they can start a new attempt session
                     alert("Démarrage d'une nouvelle session d'examen.");
                     const startTime = getClientTime().getTime();
                     localStorage.setItem('examStartTime_methodologie', startTime.toString());
                     startExam(userData);
                 }
            } else {
                 // Not logged in, show login page
                 // Clear any orphaned local data just in case
                 localStorage.removeItem('examUser');
                 localStorage.removeItem('examAnswers');
                 localStorage.removeItem('examStartTime_methodologie');
                 showLogin();
            }
        });

         // Clean up intervals and Firebase listeners when the window is closed or navigated away
         window.addEventListener('beforeunload', () => {
             stopExamTimer(); // Ensure timer interval is cleared
             // Unsubscribe Firebase listeners if they are active (registered count listener)
             stopRegisteredCounterListener();

             // If currently in exam state, attempt to save answers one last time
             if (!examSection.classList.contains('hidden')) {
                  saveAnswers(); // This saves answers and start time
             }
             // If not in exam, local data is already cleared on logout or handled by load logic
         });
    </script>
</body>
</html>